<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>计数排序 | Ronaldo</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="摘抄自：https://www.cnblogs.com/developerY/p/3166462.html       https://blog.csdn.net/gaoruxue918/article/details/61467416
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;它是一个不需要比较的,类似于桶排序的线性时间排序算法。该算法是对已知数量范围的数组(元素必">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="计数排序 | Ronaldo">
    <meta name="twitter:description" content="摘抄自：https://www.cnblogs.com/developerY/p/3166462.html       https://blog.csdn.net/gaoruxue918/article/details/61467416
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;它是一个不需要比较的,类似于桶排序的线性时间排序算法。该算法是对已知数量范围的数组(元素必">

    <meta property="og:type" content="article">
    <meta property="og:title" content="计数排序 | Ronaldo">
    <meta property="og:description" content="摘抄自：https://www.cnblogs.com/developerY/p/3166462.html       https://blog.csdn.net/gaoruxue918/article/details/61467416
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;它是一个不需要比较的,类似于桶排序的线性时间排序算法。该算法是对已知数量范围的数组(元素必">

    
    <meta name="author" content="lizhongzhen">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/logo.jpg">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Ronaldo" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2018/03/30/计数排序/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/Daniel.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Ronaldo 的主页"><img src="/images/logo.jpg" width="80" alt="Ronaldo logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Ronaldo">Ronaldo</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">文字阁</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/3298783260/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/lizhongzhen11" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-03-30T05:13:57.624Z" class="post-list__meta--date date">2018-03-30</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       阅读 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">计数排序</h1>
  </header>

  <section class="post">
    <p>摘抄自：<a href="https://www.cnblogs.com/developerY/p/3166462.html" target="_blank" rel="external">https://www.cnblogs.com/developerY/p/3166462.html</a><br>       <a href="https://blog.csdn.net/gaoruxue918/article/details/61467416" target="_blank" rel="external">https://blog.csdn.net/gaoruxue918/article/details/61467416</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个不需要比较的,类似于桶排序的线性时间排序算法。该算法是对<strong>已知数量范围</strong>的数组(<strong>元素必须是整数</strong>)进行排序。其时间复杂度为O(n),适用于<strong>小范围集合</strong>的排序。计数排序是用来排序0到100之间的数字的最好的算法。<br><strong>基本思想：</strong></p>
<blockquote>
<p>对于给定的输入序列中的每一个元素x,确定该序列中值小于x的元素的个数。一旦有了这个信息,就可以将x直接存放到最终的输出序列的正确位置上。它创建一个长度为这个数据范围的数组C,C中每个元素记录要排序数组中对应记录的出现个数。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更好的理解计数排序,我们先来想象一下如果一个数组里所有元素都是整数,而且都在0-k(<strong>这里的k可不是数组长度也不是数组下标,而是数组中最大的数值</strong>)以内。那对于数组里每个元素来说,如果我能知道数组里有多少项小于或等于该元素。我就能准确地给出该元素在排序后的数组的位置。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设已知数组a = [1,0,3,1,0,1,1],我知道了a数组的长度为<strong>7</strong>,且里面有<strong>0,1,3三种数值</strong>,那么比3小的有6个,是不是就可以确定3应该排在最后呢？比1小的有两个,那么1是不是从第三位开始排列呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候我应该循环遍历一次分别得到0,1,3在a数组中出现的次数即2,4,1(0出现了两次,1出现了4次,2没有,3出现了1次),我可以创建一个数组c,长度为4,然后<code>c[0] = 2, c[1] = 4, c[2] = 0, c[3] = 1</code>。这个数组c又是怎么回事呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实<strong>c数组的下标 = a数组的元素</strong>(所以要求a数组元素都是整数)。但是由于a数组里面没有2却有3,那总不能让c数组没有下标2吧,<strong>所以<code>c[2] = 0</code>但是<code>c[3] = 1</code>且c的长度为4</strong>。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>通过上面的例子我可以知道,c.length(c是需要给我用来过渡的数组) = k(k是需要排序的数组内最大的数值) + 1,那么a(a是需要排序的数组)里面的所有数值应该都在0~k之间,但是,a可能并不包含所有0~k之间的数值！那么a中没有的数值假设为x,c[x]应该等于0</strong>。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到了这一步,我已经看到了胜利的曙光！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来可以创建一个用于保存排序后的数组b,只需要对刚刚过渡的数组c进行遍历然后存数据即可。也就是<code>b[0] = 0, b[1] = 0, b[2] = 1, b[3] = 1, b[4] = 1, b[5] = 1, b[6] = 3</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自己动手实现一遍,看自己是不是真的能融会贯通：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">public class CountSort &#123;</div><div class="line">	private static int[] countSort(int[] array,int k) &#123;</div><div class="line">        int sum = 0;</div><div class="line">        int B[] = new int[array.length]; // 最终用于返回的数组</div><div class="line">        int C[] = new int[k + 1]; // 用于过渡的数组</div><div class="line">        // 接下来我需要通过for循环遍历,得到每个元素在array里面出现的次数</div><div class="line">        for(int i = 0; i &lt; array.length; i++) &#123;</div><div class="line">            // 记住：array数组中的元素是 C 数组的下标</div><div class="line">            // array[i]肯定是存在的,所以默认有一个,至于有多少个,通过遍历不断 +1 即可</div><div class="line">            // 比如这里array[0]是2,但是array[4]也是2.所以这里 array[0] == array[4] == 2,</div><div class="line">            // 意味着 C[2] 出现两次,所以 C[2] = 2,所以每当出现过相同的array[i]时就 +1</div><div class="line">            C[array[i]] += 1; </div><div class="line">        &#125;</div><div class="line">        // 这里面有一个巧妙的思路就是利用数组下标,他会自动帮我们排序,毕竟数值是C数组的下标。</div><div class="line">        // 这个时候我该考虑怎么把数据从 C 数组中取出来放到 B 数组了</div><div class="line">        for(int i = 0; i &lt; k + 1; i++) &#123;</div><div class="line">            // 这时候的 C[i], i 其实是 array里面的元素, C[i] 其实是该元素的个数</div><div class="line">            // i 从0开始递增到 k 即最大值,但是,我能保证i包含 0~k中所有的数值吗？</div><div class="line">            // 对不起,我不能保证！！！</div><div class="line">            // 但是,不用担心！编译器会自动帮我们把数组中没有值的但是却必须存在的下标对应的值初始化为 0</div><div class="line">            if(C[i] != 0) &#123; // 代表存在该值</div><div class="line">                int x = C[i]; // 过渡下</div><div class="line">                // 由于C[i] 其实对应的是 A 数组里相同数据存在的个数,那么我只需对个数遍历即可。</div><div class="line">                // 但是我这里又困住了,第一轮循环从 0 开始确立前几个数组元素是没问题的,比如第一次遍历的是数值为0的个数并进行赋值</div><div class="line">                // 关键问题是当第二轮循环,开始遍历数值为2的个数进行赋值时,我不可能继续从B[0]开始</div><div class="line">                // 我应该紧接着上一轮循环后的下标开始,所以这里我需要引入一个变量 sum</div><div class="line">                for(int j = 0; j &lt; x; j++) &#123;</div><div class="line">                    // 这里一开始我写的是B[j] = i,经过实践发现这是不对的,后来我意识到了不能每次都从0开始,</div><div class="line">                    // 就改成了 B[sum + j] = i,依然是错误的。因为sum++不断自增,最终sum是会跟array.length相等,加上j就明显超过数组长度了</div><div class="line">                    // 我也尝试修改 j &lt; x+sum,继续打了脸,这里的 x 再三强调是相同数值的个数,我不能凭空给它增加啊</div><div class="line">                    B[sum] = i; </div><div class="line">                    sum++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return B;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] A = new int[]&#123;2,5,3,0,2,3,0,3&#125;;</div><div class="line">        int[] B = countSort(A, 5);</div><div class="line">        for(int i = 0; i &lt; B.length; i++) &#123;</div><div class="line">        	System.out.println(&quot;B[&quot; + i + &quot;] = &quot; + B[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是,仔细看我的实现代码,用到了三个for循环,其中两个是嵌套的,这样效率并不算好吧。都说在小范围内使用计数排序效率高,可按我这样写怎么也跟高效率扯不上关系。而且算法思想说找到统计不大于数值的总数就能确定位置,我这好像有点驴头不对马嘴。那么该怎么做呢？直接贴出网上大神的代码吧。</p>
</blockquote>
<p>网上的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">package com.lizz.set;</div><div class="line">public class CountSort &#123;</div><div class="line">	private static int[] countSort(int[] array,int k) &#123;</div><div class="line">        int[] C = new int[k+1]; // 构造C数组</div><div class="line">        int length = array.length, sum = 0; // 获取A数组大小用于构造B数组  </div><div class="line">        int[] B = new int[length]; // 构造B数组</div><div class="line">        for(int i = 0; i &lt; length; i++) &#123;</div><div class="line">            C[array[i]] += 1; // 统计A中各元素个数，存入C数组</div><div class="line">        &#125;</div><div class="line">        for(int i = 0; i &lt; k+1; i++) &#123; // 修改C数组</div><div class="line">            System.out.println(C[i]);</div><div class="line">            sum += C[i];</div><div class="line">            C[i] = sum;    </div><div class="line">            // System.out.println(C[i]);</div><div class="line">        &#125;</div><div class="line">        for(int i = length-1; i &gt;= 0; i--) &#123; // 遍历A数组，构造B数组</div><div class="line">            B[C[array[i]]-1] = array[i]; // 将A中该元素放到排序后数组B中指定的位置</div><div class="line">            C[array[i]]--; // 将C中该元素-1，方便存放下一个同样大小的元素</div><div class="line">        &#125;</div><div class="line">        return B; // 将排序好的数组返回，完成排序</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] A = new int[]&#123;2,5,3,0,2,3,0,3&#125;;</div><div class="line">        int[] B = countSort(A, 5);</div><div class="line">        for(int i = 0; i &lt; A.length; i++) &#123;</div><div class="line">            System.out.println((i+1) + &quot;th:&quot; + B[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">1th:0</div><div class="line">2th:0</div><div class="line">3th:2</div><div class="line">4th:2</div><div class="line">5th:3</div><div class="line">6th:3</div><div class="line">7th:3</div><div class="line">8th:5</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网上的代码中,第二个for循环我没看明白,然后我就打印了下<code>C[i]</code>,<code>C[i] = sum</code>之前打印出是<strong>2,0,2,3,0,1</strong>,分别对应<strong>0,1,2,3,4,5</strong>出现的次数;重新赋值后打印出来是<strong>2,2,4,7,7,8</strong>。<code>sum</code>最终是8,到了第三个for循环,<code>array[i]</code>是<strong>3,0,3,2,0,3,5,2</strong>,<code>C[array[i]]</code>是<strong>72641583</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我想了半天,为什么要重新赋值？后来在 <a href="https://www.cnblogs.com/lustar/p/7308089.html" target="_blank" rel="external">https://www.cnblogs.com/lustar/p/7308089.html</a> 这里的注释找到了答案。这里修改<code>C[i]</code>其实是为了统计不大于相应数值的总数。因为思想里说了,<strong>我要得到不大于某个数值的总数</strong>就能得到它在数组中的正确位置了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然理解了这里的赋值修改,那么修改后的<code>C[0]</code>是2,代表不大于0的数有两个。以此类推。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么第三个for循环内部的代码是什么意思呢？我将它剖开分析。</p>
<ul>
<li><code>array[i]</code>其实就是原数组对应的元素同时也是C数组的对应下标！</li>
<li>但是此时的<code>C[array[i]]</code>得到的值其实是不大于<code>array[i]</code>的值的总数假设为<strong>x</strong>(包含<code>array[i]</code>对应的个数)。那么是不是意味着<code>array</code>数组中 &lt;= <code>array[i]</code>的元素一共有<strong>x</strong>个？<strong>不过我也不能保证<code>array[i]</code>对应的值在数组中唯一且没有相等的！</strong>那么是不是意味着与<code>array[i]</code>对应的值相等的数据中一定有一个排序后应该在数组中第<strong>x-1</strong>位(这里的x是个数,从1开始,而数组下标是从0开始的)？<br><strong>如果数组中有其他与<code>array[i]</code>对应的值相等,那么我该怎么确定这些相等的值排序顺序呢？</strong><br><strong>这里不得不佩服前辈们的思想了,用for循环从后向前遍历！！！为什么？？？</strong><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<code>i</code>是从后向前遍历的,那么即使数组中存在多个值与<code>array[i]</code>相等也不用慌,直接先排<code>array[i]</code>就好了,毕竟即使几个值相等,<strong>我为了保证数组稳定性,那么在原数组中下标较大的自然在新数组中所有相同的值里面排在相对靠后位置</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么接下来的<code>C[array[i]]--</code>也应该很明白了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们想想,<code>i</code>一开始是<code>8-1=7</code>,<code>array[7] == 3</code>,<code>C[3]</code>代表不大于<code>3</code>的总数一共有7个。而<code>array</code>中除了<code>array[7]</code>等于3外还有<code>array[2]</code>和<code>array[5]</code>的值都是3,那么是不是<code>i</code>循环遍历到2和5时,都是<code>C[3]</code>?可我在<code>i == 7</code>时已经将<code>array[7]</code>排好位置了,它不应该继续参与排序了,所以有相同值时,应该排好一个减去一个。</p>
</blockquote>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后,做个象征性的总结,当我们学习时,一定要手动去实践,有不懂得或者不是特别理解的就去实践,实践不仅是检验真理的唯一标准,还是提升技术的最强方法。</p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/04/02/位运算符计算平均值/" title="为什么在 Java 中用 (low+high)&gt;&gt;&gt;1 代替 (low+high)/2 或 (low+high)&gt;&gt;1 来计算平均值呢？好在哪里？">为什么在 Java 中用 (low+high)&gt;&gt;&gt;1 代替 (low+high)/2 或 (low+high)&gt;&gt;1 来计算平均值呢？好在哪里？</a></h2>
                <p class="excerpt">
                
                抄自：https://www.cnblogs.com/zt007/p/7169735.html?utm_source=itdadao&amp;amp;utm_medium=referral

&amp;gt;&amp;gt;&amp;gt;与&amp;gt;&amp;gt;是位运算符,只对整型有效(不能用于浮点型)。当是整型的时候(low+hig
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-04-02T02:34:14.719Z" class="post-list__meta--date date">2018-04-02</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/04/02/位运算符计算平均值/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/03/30/javaSort/" title="java sort 方法源码学习">java sort 方法源码学习</a></h2>
                <p class="excerpt">
                
                &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在学习《Thinking in java》集合一章时,快到末尾时讲解了排序和搜索中用到了sort(),点进去看了下源码,发现第一遍看起来还有点不甚了解,遂专开一篇来学习理解。
一、sort(byte[] a, int left,
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-03-30T01:52:23.057Z" class="post-list__meta--date date">2018-03-30</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/03/30/javaSort/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 lizhongzhen - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
