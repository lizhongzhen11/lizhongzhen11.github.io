<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Thinking in Java 学习笔记 | Ronaldo</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="一、目录
java基础数据类型
假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？
构造函数
垃圾收集
成员初始化
public, protected, default(friendly), private 对应的访问权限
final
方法过载与覆盖
抽象方法
接口
多重继承
多态
继承和 finalize()
构建器内部的多形性方法的行为
集合
Vector">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Thinking in Java 学习笔记 | Ronaldo">
    <meta name="twitter:description" content="一、目录
java基础数据类型
假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？
构造函数
垃圾收集
成员初始化
public, protected, default(friendly), private 对应的访问权限
final
方法过载与覆盖
抽象方法
接口
多重继承
多态
继承和 finalize()
构建器内部的多形性方法的行为
集合
Vector">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Thinking in Java 学习笔记 | Ronaldo">
    <meta property="og:description" content="一、目录
java基础数据类型
假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？
构造函数
垃圾收集
成员初始化
public, protected, default(friendly), private 对应的访问权限
final
方法过载与覆盖
抽象方法
接口
多重继承
多态
继承和 finalize()
构建器内部的多形性方法的行为
集合
Vector">

    
    <meta name="author" content="lizhongzhen">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/logo.jpg">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Ronaldo" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2018/03/20/thinkingInJava/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/Daniel.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Ronaldo 的主页"><img src="/images/logo.jpg" width="80" alt="Ronaldo logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Ronaldo">Ronaldo</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="https://github.com/lizhongzhen11/lizhongzhen11.github.io">目录</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/3298783260/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" title="Weibo" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/lizhongzhen11" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-03-20T05:25:01.159Z" class="post-list__meta--date date">2018-03-20</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Thinking in Java 学习笔记</h1>
  </header>

  <section class="post">
    <h2 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、<a id="123">目录</a></h2><ol>
<li><a href="#1">java基础数据类型</a></li>
<li><a href="#2">假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？</a></li>
<li><a href="#3">构造函数</a></li>
<li><a href="#4">垃圾收集</a></li>
<li><a href="#5">成员初始化</a></li>
<li><a href="#6">public, protected, default(friendly), private 对应的访问权限</a></li>
<li><a href="#7">final</a></li>
<li><a href="#8">方法过载与覆盖</a></li>
<li><a href="#9">抽象方法</a></li>
<li><a href="#10">接口</a></li>
<li><a href="#11">多重继承</a></li>
<li><a href="#12">多态</a></li>
<li><a href="#13">继承和 finalize()</a></li>
<li><a href="#14">构建器内部的多形性方法的行为</a></li>
<li><a href="#15">集合</a><ul>
<li><a href="#151">Vector</a></li>
<li><a href="#152">枚举器 Iterator</a></li>
<li><a href="#153">BitSet</a></li>
<li><a href="#154">Stack</a></li>
<li><a href="#155">Hashtable</a></li>
<li><a href="#156">排序</a></li>
<li><a href="#157">新集合</a><ul>
<li><a href="#1571">removeAll()以及retainAll()</a></li>
<li><a href="#1572">Lists</a></li>
<li><a href="#1573">Sets</a></li>
<li><a href="#1574">Maps</a></li>
<li><a href="#1575">Arrays.binarySearch</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#16">java的I/O</a></li>
<li><a href="#17">线程</a></li>
</ol>
<h2 id="二、内容"><a href="#二、内容" class="headerlink" title="二、内容"></a>二、内容</h2><h3 id="1、java基础数据类型"><a href="#1、java基础数据类型" class="headerlink" title="1、java基础数据类型"></a>1、<a id="1">java基础数据类型</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java基础数据类型：<strong>int, float, double, boolean, short, long, byte以及char</strong>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中,char类型是一个单一的 16 位 Unicode 字符。char类型用单引号表示也可以是整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cahr a = &apos;a&apos;; // 必须限定长度为一个字节。等效于 char a = 97; 因为&apos;a&apos;在ASCII码表里对应97.</div><div class="line">char b = &apos;中文&apos;;</div><div class="line">char c = 97;</div><div class="line">System.out.println(a == c); // true</div></pre></td></tr></table></figure></p>
<h3 id="2、假设一个值是29-7，我们把它强转成一个char，那么结果值到底是-30-还是29-呢？"><a href="#2、假设一个值是29-7，我们把它强转成一个char，那么结果值到底是-30-还是29-呢？" class="headerlink" title="2、假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？"></a>2、<a id="2">假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个 float 或 double 值造型成整数值后，总是将小数部分“砍掉”，不作任何进位处理。所以结果是29.</p>
<h3 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、<a id="3">构造函数</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造函数是在产生对象时被java系统<strong>自动调用</strong>的，我们不能在程序中像调用其他方法一样去调用构造方法（<strong>必须通过关键词new自动调用它</strong>）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造器属于一种较特殊的方法类型，因为它没有返回值。<br><strong>注意！</strong></p>
<ul>
<li>构造器里通过<code>this</code>调另一个构造器,只能调用一个,不能调用两个。</li>
<li>除构造器之外的方法不能调用构造器。</li>
</ul>
<h3 id="4、垃圾收集"><a href="#4、垃圾收集" class="headerlink" title="4、垃圾收集"></a>4、<a id="4">垃圾收集</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<ul>
<li>垃圾收集并不等于“破坏”！</li>
<li>我们的对象可能不会当作垃圾被收掉！</li>
<li>垃圾收集只跟内存有关！</li>
</ul>
<p>不必过多地使用<code>finalize()</code>。它并不是进行普通清除工作的理想场所。<code>finalize()</code>最有用处的地方之一是观察垃圾收集的过程。</p>
<h3 id="5、成员初始化"><a href="#5、成员初始化" class="headerlink" title="5、成员初始化"></a>5、<a id="5">成员初始化</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 尽自己的全力保证所有变量都能在使用前得到正确的初始化。若被定义成相对于一个方法的“局部”变量，这一保证就通过编译期的出错提示表现出来。因此，如果使用下述代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void f() &#123;</div><div class="line">    int i;</div><div class="line">    i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码会报错,提示未初始化。但是这样改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class InitialValues &#123;</div><div class="line">    private int i;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        InitialValues initialValues = new InitialValues();</div><div class="line">        System.out.println(initialValues.i);  // 0</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>能正常运行且<code>i</code>有一个初始值0.</p>
<ul>
<li><p>初始化顺序<br>  在一个类里,初始化的顺序是由变量在类内的定义顺序决定的。即使变量定义大量遍布于方法定义的中间,那些变量仍会在调用任何方法之前得到初始化——甚至在构建器调用之前。<br>  初始化的顺序是首先<strong>static</strong>(如果它们尚未由前一次对象创建过程初始化),接着是非static 对象,然后再构造器。</p>
</li>
<li><p>明确进行的静态初始化<br>  <strong><code>static</code>关键字定义的变量以及代码块在类初始化的时候就执行了,属于静态资源。</strong><br>  这里一开始我有一个误区：我一开始以为只要实例化一个对象就把该类初始化一遍,初始化一遍是不是也就把<code>static</code>关键字定义的内容也初始化一次。<br>  事实上,这种理解是错误的。<strong><code>static</code>修饰的内容在类第一次初始化后就当做静态资源暂存在java虚拟机上了,以后不管类初始化几次,都不会再对<code>static</code>修饰的内容初始化。</strong>做个比喻：一个类第一次初始化后就好比王者荣耀英雄刚进战场,把<code>static</code>修饰的内容赋为它的被动属性,被动属性英雄出场自带,其他属性升级(类被实例化)才能学到。<br>  所以下方代码执行后,明明实例化了两次<code>Cups</code>,但却只打印一次<code>Cup(1) Cup(2)</code>。因为第一次初始化后,<code>static</code>修饰的内容就不会再度执行了。</p>
</li>
</ul>
<p>看下面代码对比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class ExplicitStatic &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(&quot;Inside main()&quot;);</div><div class="line">		Cups.c1.f(99);</div><div class="line">	&#125;</div><div class="line">	static Cups x = new Cups();</div><div class="line">	static Cups y = new Cups();</div><div class="line">&#125;</div><div class="line">class Cup &#123;</div><div class="line">	public Cup(int marker) &#123;</div><div class="line">		System.out.println(&quot;Cup(&quot; + marker + &quot;)&quot;);</div><div class="line">	&#125;</div><div class="line">	void f(int marker) &#123;</div><div class="line">		System.out.println(&quot;f(&quot; + marker + &quot;)&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Cups &#123;</div><div class="line">	static Cup c1;</div><div class="line">	static Cup c2;</div><div class="line">	static &#123;</div><div class="line">		c1 = new Cup(1);</div><div class="line">		c2 = new Cup(2);</div><div class="line">	&#125;</div><div class="line">	public Cups() &#123;</div><div class="line">		System.out.println(&quot;Cups()&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码最终打印如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">Cups()</div><div class="line">Cups()</div><div class="line">Inside main()</div><div class="line">f(99)</div></pre></td></tr></table></figure></p>
<p>但是如果把<code>Cups</code>类里面的<code>static</code>代码块前的<code>static</code>去掉,打印如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">Cups()</div><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">Cups()</div><div class="line">Inside main()</div><div class="line">f(99)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果不进行<code>Cups</code>的实例化呢？<br>直接把<code>static Cups x = new Cups(); static Cups y = new Cups();</code>注释掉,会发现打印输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Inside main()</div><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">f(99)</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>初始化一个类并不仅仅靠实例化,通过 类.属性名 或者 类.方法也可以对类进行初始化！</strong></p>
<h3 id="6、public-protected-default-friendly-private-对应的访问权限"><a href="#6、public-protected-default-friendly-private-对应的访问权限" class="headerlink" title="6、public, protected, default(friendly), private 对应的访问权限"></a>6、<a id="6">public, protected, default(friendly), private 对应的访问权限</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类本身  同一包内  子孙类  不同包<br><strong>public</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>   <br><br><strong>protected</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>   <br><br><strong>default</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>   <br><br><strong>private</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong></p>
<h3 id="7、final"><a href="#7、final" class="headerlink" title="7、final"></a>7、<a id="7">final</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<ul>
<li><code>final</code>修饰的变量不能被重新赋值修改。</li>
<li><code>final</code>修饰的方法不能被继承类修改。</li>
<li><code>final</code>修饰的变量在定义时可以没有初始值,但是必须在构造器里赋值。</li>
<li><code>final</code>修饰的类不能被继承。</li>
<li><code>final</code>可以有效的关闭“动态绑定”。</li>
</ul>
<h3 id="8、方法过载与覆盖"><a href="#8、方法过载与覆盖" class="headerlink" title="8、方法过载与覆盖"></a>8、<a id="8">方法过载与覆盖</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<blockquote>
<p>“过载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。</p>
</blockquote>
<p>过载的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">	void play(int i) &#123;&#125;</div><div class="line">&#125;</div><div class="line">class C &#123;</div><div class="line">	C() &#123;&#125;</div><div class="line">&#125;</div><div class="line">class B extends A &#123;</div><div class="line">	void play(C c) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中,B继承了A,A里面有方法<code>play</code>不过参数是<code>int</code>型的,而B里面的<code>play</code>方法参数却是C类型的,这里并不是覆盖A类里面的<code>play</code>方法,而是新增了一个使用C类型参数的<code>play</code>方法。</p>
<h3 id="9、抽象方法"><a href="#9、抽象方法" class="headerlink" title="9、抽象方法"></a>9、<a id="9">抽象方法</a></h3><p><strong><a href="#123">返回目录</a></strong><br>语法：<code>abstract void X();</code><br>它属于一种不完整的方法，只含有一个声明，没有方法主体。<br>包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成<code>abstract</code>（抽象）。否则，编译器会向我们报告一条出错消息。</p>
<blockquote>
<p>当继承抽象类时,子类必须将抽象类的抽象方法全部显式的写出来,否则报错。</p>
</blockquote>
<h3 id="10、接口"><a href="#10、接口" class="headerlink" title="10、接口"></a>10、<a id="10">接口</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将接口视为一个“纯抽象”类。它允许创建者规定一个类的基本形式：方法名、自变量列表以及返回类型，但不规定方法主体。接口也包含了基本数据类型的数据成员，但它们都默认为static 和final。接口只提供一种形式，并不提供实施的细节。</p>
<h3 id="11、多重继承"><a href="#11、多重继承" class="headerlink" title="11、多重继承"></a>11、<a id="11">多重继承</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于接口根本没有具体的实施细节——也就是说，没有存储空间与“接口”关联在一起——所以没有任何办法可以防止多个接口合并到一起。这一点是至关重要的，因为我们经常都需要表达这样一个意思：“x 从属于 a，也从属于 b，也从属于 c”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个衍生类中，我们并不一定要拥有一个抽象或具体（没有抽象方法）的基础类。如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于 <code>implements</code> 关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型。下面这个例子展示了一个“具体”类同几个接口合并的情况，它最终生成了一个新类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">interface CanFight &#123;</div><div class="line">	void fight();</div><div class="line">&#125;</div><div class="line">interface CanSwim &#123;</div><div class="line">	void swim();</div><div class="line">&#125;</div><div class="line">interface CanFly &#123;</div><div class="line">	void fly();</div><div class="line">&#125;</div><div class="line">class ActionCharacter &#123;</div><div class="line">	public void fight() &#123;&#125;</div><div class="line">&#125;</div><div class="line">class Hero extends ActionCharacter implements CanFight, CanSwim, CanFly &#123;</div><div class="line">	public void swim() &#123;&#125;</div><div class="line">	public void fly() &#123;&#125;</div><div class="line">&#125;</div><div class="line">public class Adventure &#123;</div><div class="line">	static void t(CanFight x) &#123; x.fight(); &#125;</div><div class="line">	static void u(CanSwim x) &#123; x.swim(); &#125;</div><div class="line">	static void v(CanFly x) &#123; x.fly(); &#125;</div><div class="line">	static void w(ActionCharacter x) &#123; x.fight(); &#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Hero i = new Hero();</div><div class="line"> 		t(i); // Treat it as a CanFight</div><div class="line"> 		u(i); // Treat it as a CanSwim</div><div class="line"> 		v(i); // Treat it as a CanFly</div><div class="line"> 		w(i); // Treat it as an ActionCharacter</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="12、多态"><a href="#12、多态" class="headerlink" title="12、多态"></a>12、<a id="12">多态</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<blockquote>
<p>三个必要条件：<strong>继承</strong>、<strong>重写</strong>、<strong>父类引用指向子类对象</strong>。<br>实现多态的技术称为动态绑定。是指在执行期间判断所引用对象的实际类型,根据其实际的类型调用其相应的方法。</p>
</blockquote>
<p><strong>以下内容来自知乎！</strong><br>直观的理解：<br>同一个方法名,但是参数不同,这叫方法重载。<code>Overload</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void foo(String str);</div><div class="line">void foo(int num);</div></pre></td></tr></table></figure></p>
<p>父类与子类有同样的方法名和参数,这叫方法覆盖。<code>Override</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Parent &#123;</div><div class="line">	void foo() &#123;</div><div class="line">		System.out.println(&quot;Parent foo()&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Child extends Parent &#123;</div><div class="line">	void foo() &#123;</div><div class="line">		System.out.println(&quot;Child foo()&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>父类引用指向子类对象,调用方法时会调用子类的实现,而不是父类的实现,这叫多态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Parent instance = new Child();</div><div class="line">instance.foo(); // 此处其实调用的是 Child 类里面的 foo()</div></pre></td></tr></table></figure></p>
<p>拓展深入理解下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">	int num = 10;</div><div class="line">	static int age = 20;</div><div class="line">	public void eat() &#123;</div><div class="line">		System.out.println(&quot;动物吃饭&quot;);</div><div class="line">	&#125;</div><div class="line">	public static void sleep() &#123;</div><div class="line">		System.out.println(&quot;动物在睡觉&quot;);</div><div class="line">	&#125;</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(&quot;动物在奔跑&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Cat extends Animal &#123;</div><div class="line">	int num = 80;</div><div class="line">	static int age = 90;</div><div class="line">	String name = &quot;tomCat&quot;;</div><div class="line">	public void eat() &#123;</div><div class="line">		System.out.println(&quot;猫吃饭&quot;);</div><div class="line">	&#125;</div><div class="line">	public static void sleep() &#123;</div><div class="line">		System.out.println(&quot;猫在睡觉&quot;);</div><div class="line">	&#125;</div><div class="line">	public void catchMouse() &#123;</div><div class="line">		System.out.println(&quot;猫在抓老鼠&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类Demo_Test1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Demo_Test1 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Animal am = new Cat();</div><div class="line">		am.eat();</div><div class="line">		am.sleep();</div><div class="line">		am.run();</div><div class="line">//		am.catchMouse();  报错,Animal类里没有这个方法。</div><div class="line">//		System.out.println(am.name);  报错</div><div class="line">		System.out.println(am.num);</div><div class="line">		System.out.println(am.age);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 打印输出</div><div class="line">猫吃饭</div><div class="line">动物在睡觉</div><div class="line">动物在奔跑</div><div class="line">10</div><div class="line">20</div></pre></td></tr></table></figure></p>
<p>由上述例子可以看出：</p>
<ul>
<li>子类 <code>Cat</code> 中重写或者覆盖了父类 <code>Animal</code> 中的 <code>eat()</code>,所以打印输出了 猫吃饭。</li>
<li>子类 <code>Cat</code> 中虽然也重新对父类<code>Animal</code>中的 <code>sleep()</code> 进行重写,但是输出发现并未覆盖掉父类的方法。仔细观察发现,<strong>该方法是静态的,不会被覆盖</strong>。</li>
<li>子类 <code>Cat</code> 中虽然也重新对父类<code>Animal</code>中的 <code>num</code> 和 <code>age</code> 进行赋值期望覆盖父类,但是由于<code>age</code>也是静态的,依旧不能被覆盖。<strong>不过需要着重关注的是<code>num</code>,该变量不是静态的,也没有用<code>final</code>修饰,却依然未被覆盖</strong>。</li>
<li>上述代码中有两处报错,分别是子类定义的<code>name</code>变量以及<code>catchMouse()</code>！<br>对这个现象的理解应该是,<code>am</code>声明时是<code>Animal</code>类型,虽然给它赋值了<code>Cat</code>类型并没有报错,但那是因为<code>Cat</code>类型继承自<code>Animal</code>类型,所以可以赋值。<strong>不过,<code>am</code>的本质依然是<code>Animal</code>类型而不是<code>Cat</code>类型,<code>Animal</code>类型中并没有<code>name</code>变量以及<code>catchMouse()</code>,所以会报错</strong>。</li>
</ul>
<blockquote>
<p>那么可以总结出多态成员访问的特点：<br><strong>成员变量</strong><br>编译看左边(父类),运行也看左边(父类)。<br><strong>成员方法</strong><br>编译看左边(父类),运行却看右边(子类)。动态绑定。<br><strong>静态方法</strong><br>编译看左边(父类),运行也看左边(父类)。<br><strong>只有非静态成员的方法,编译才看左边,运行看右边。</strong></p>
</blockquote>
<p>从上述例子可以看出,多态有一个弊端即无法访问子类定义的方法和变量。<br>怎么才能访问子类的方法和变量呢？<br><strong>强转</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Cat ct = (Cat)am;</div><div class="line">ct.catchMouse();</div><div class="line">System.out.println(ct.name);</div></pre></td></tr></table></figure></p>
<h3 id="13、继承和-finalize"><a href="#13、继承和-finalize" class="headerlink" title="13、继承和 finalize()"></a>13、<a id="13">继承和 finalize()</a></h3><p><strong><a href="#123">返回目录</a></strong><br>看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">package com.lizz.finalize;</div><div class="line">public class Frog extends Amphibian &#123;</div><div class="line">	Frog() &#123;</div><div class="line">		System.out.println(&quot;Frog()&quot;);</div><div class="line">	&#125;</div><div class="line">	protected void finalize() &#123;</div><div class="line">		System.out.println(&quot;Frog finalize&quot;);</div><div class="line">		if(DoBaseFinalization.flag) &#123;</div><div class="line">			try &#123;</div><div class="line">				super.finalize();</div><div class="line">			&#125; catch (Throwable e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		if(args.length != 0 &amp;&amp; args[0].equals(&quot;finalize&quot;)) &#123;</div><div class="line">			DoBaseFinalization.flag = true;</div><div class="line">		&#125; else &#123;</div><div class="line">			System.out.println(&quot;not finalizing bases&quot;);</div><div class="line">		&#125;</div><div class="line">		new Frog();</div><div class="line">		System.out.println(&quot;bye!&quot;);</div><div class="line">		System.runFinalizersOnExit(true);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class DoBaseFinalization &#123;</div><div class="line">	public static boolean flag = false;</div><div class="line">&#125;</div><div class="line">class Characteristic &#123;</div><div class="line">	String s;</div><div class="line">	Characteristic(String c) &#123;</div><div class="line">		s = c;</div><div class="line">		System.out.println(&quot;Creating Character &quot; + s);</div><div class="line">	&#125;</div><div class="line">	protected void finalize() &#123;</div><div class="line">		System.out.println(&quot;finalizing Characteristic &quot; + s);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class LivingCreature &#123;</div><div class="line">	Characteristic p = new Characteristic(&quot;is alive&quot;);</div><div class="line">	LivingCreature() &#123;</div><div class="line">		System.out.println(&quot;LivingCreature()&quot;);</div><div class="line">	&#125;</div><div class="line">	protected void finalize() &#123;</div><div class="line">		System.out.println(&quot;LivingCreature finalize&quot;);</div><div class="line">		if(DoBaseFinalization.flag) &#123;</div><div class="line">			try &#123;</div><div class="line">				super.finalize();</div><div class="line">			&#125; catch (Throwable e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Animal extends LivingCreature &#123;</div><div class="line">	Characteristic p = new Characteristic(&quot;has heart&quot;);</div><div class="line">	Animal() &#123;</div><div class="line">		System.out.println(&quot;Animal()&quot;);</div><div class="line">	&#125;</div><div class="line">	protected void finalize() &#123;</div><div class="line">		System.out.println(&quot;Animal finalize&quot;);</div><div class="line">		if(DoBaseFinalization.flag) &#123;</div><div class="line">			try &#123;</div><div class="line">				super.finalize();</div><div class="line">			&#125; catch (Throwable e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Amphibian extends Animal &#123;</div><div class="line">	Characteristic p = new Characteristic(&quot;can live in water&quot;);</div><div class="line">	Amphibian() &#123;</div><div class="line">		System.out.println(&quot;Amphibian()&quot;);</div><div class="line">	&#125;</div><div class="line">	protected void finalize() &#123;</div><div class="line">		System.out.println(&quot;Amphibian finalize&quot;);</div><div class="line">		if(DoBaseFinalization.flag) &#123;</div><div class="line">			try &#123;</div><div class="line">				super.finalize();</div><div class="line">			&#125; catch (Throwable e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 打印输出：</div><div class="line">not finalizing bases</div><div class="line">Creating Character is alive</div><div class="line">LivingCreature()</div><div class="line">Creating Character has heart</div><div class="line">Animal()</div><div class="line">Creating Character can live in water</div><div class="line">Amphibian()</div><div class="line">Frog()</div><div class="line">bye!</div><div class="line">finalizing Characteristic can live in water</div><div class="line">finalizing Characteristic has heart</div><div class="line">finalizing Characteristic is alive</div><div class="line">Frog finalize</div></pre></td></tr></table></figure></p>
<blockquote>
<p>仔细观察代码和后4个输出,发现输出顺序是从<strong>最低级的子类不断往上一直到基础类</strong>,也就是说<code>finalize()</code>是从最下面的子类不断向上调用的。<br>按照与 C++ 中用于“破坏器”相同的形式，我们应该首先执行衍生类的收尾，再是基础类的收尾。这是由于衍生类的收尾可能调用基础类中相同的方法，要求基础类组件仍然处于活动状态。因此，必须提前将它们清除（破坏）。</p>
</blockquote>
<h3 id="14、构建器内部的多形性方法的行为"><a href="#14、构建器内部的多形性方法的行为" class="headerlink" title="14、构建器内部的多形性方法的行为"></a>14、<a id="14">构建器内部的多形性方法的行为</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<blockquote>
<p>设计构建器时一个特别有效的规则是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用尽可能简单的方法使对象进入就绪状态；如果可能,避免调用任何方法。在构建器内唯一能够安全调用的是在基础类中具有<code>final</code> 属性的那些方法(也适用于<code>private</code>方法,它们自动具有<code>final</code> 属性)。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>若调用构建器内部一个动态绑定的方法,会使用那个方法被覆盖的定义</strong>。然而,产生的效果可能并不如我们所愿,而且可能造成一些难于发现的程序错误。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从概念上讲,构建器的职责是让对象实际进入存在状态。<strong>在任何构建器内部,整个对象可能只是得到部分组织——我们只知道基础类对象已得到初始化,但却不知道哪些类已经继承。然而,一个动态绑定的方法调用却会在分级结构里“向前”或者“向外”前进。它调用位于衍生类里的一个方法。</strong>如果在构建器内部做这件事情,那么对于调用的方法,它要操纵的成员可能尚未得到正确的初始化——这显然不是我们所希望的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.lizz.polymorphism;</div><div class="line">public class PolyConstructors &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new RoundGlyph(5);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">abstract class Glyph &#123;</div><div class="line">	abstract void draw();</div><div class="line">	Glyph() &#123;</div><div class="line">		System.out.println(&quot;Glyph() before draw()&quot;);</div><div class="line">		draw();</div><div class="line">		System.out.println(&quot;Glyph() after draw()&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class RoundGlyph extends Glyph &#123;</div><div class="line">	int radius = 1;</div><div class="line">	RoundGlyph(int i) &#123;</div><div class="line">		radius = i;</div><div class="line">		System.out.println(&quot;RoundGlyph.RoundGlyph(), radius = &quot; + radius);</div><div class="line">	&#125;</div><div class="line">	void draw() &#123;</div><div class="line">		System.out.println(&quot;RoundGlyph.drwa(), radius = &quot; + radius);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 打印输出：</div><div class="line">Glyph() before draw()</div><div class="line">RoundGlyph.drwa(), radius = 0</div><div class="line">Glyph() after draw()</div><div class="line">RoundGlyph.RoundGlyph(), radius = 5</div></pre></td></tr></table></figure>
<p>仔细观察上述代码以及输出,发现<code>Glyph</code>初始化调用构造器时,其内部的<code>draw()</code>并没有定义方法主体但是却打印输出了<code>RoundGlyph</code>类内部重写的<code>draw()</code>方法。<br>初始化的实际过程：</p>
<ul>
<li>在采取其他任何操作之前，为对象分配的存储空间初始化成二进制零。</li>
<li>就象前面叙述的那样,调用基础类构建器。此时,被覆盖的<code>draw()</code>方法会得到调用(的确是在 <code>RoundGlyph</code> 构建器调用之前),此时会发现 <code>radius</code> 的值为 0,这是由于步骤(1)造成的。</li>
<li>按照原先声明的顺序调用成员初始化代码。</li>
<li>调用衍生类构建器的主体。</li>
</ul>
<h3 id="15、集合"><a href="#15、集合" class="headerlink" title="15、集合"></a>15、<a id="15">集合</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们编写程序时,通常并不能确切地知道最终需要多少个对象。有些时候甚至想用更复杂的方式来保存对象。为解决这个问题,Java 提供了四种类型的“集合类”：<strong>Vector(矢量)、BitSet(位集)、Stack(堆栈)以及Hashtable(散列表)</strong>。<br><strong>所有Java 集合类都能自动改变自身的大小</strong>。</p>
</blockquote>
<h3 id="15-1、Vector"><a href="#15-1、Vector" class="headerlink" title="15.1、Vector"></a><a id="151">15.1、Vector</a></h3><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">package com.lizz.set;</div><div class="line">import java.util.Vector;</div><div class="line">public class CatsAndDogs &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Vector cats = new Vector();</div><div class="line">		for(int i = 0; i &lt; 7; i++) &#123;</div><div class="line">			cats.addElement(new Cat(i));</div><div class="line">		&#125;</div><div class="line">		cats.addElement(new Dog(7));</div><div class="line">		for(int i = 0; i &lt; cats.size(); i++) &#123;</div><div class="line">			((Cat)cats.elementAt(i)).print();;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Cat &#123;</div><div class="line">	private int catNumber;</div><div class="line">	Cat(int i) &#123;</div><div class="line">		catNumber = i;</div><div class="line">	&#125;</div><div class="line">	void print() &#123;</div><div class="line">		System.out.println(&quot;Cat #&quot; + catNumber);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Dog &#123;</div><div class="line">	private int dogNumber;</div><div class="line">	Dog(int i) &#123;</div><div class="line">		dogNumber = i;</div><div class="line">	&#125;</div><div class="line">	void print() &#123;</div><div class="line">		System.out.println(&quot;Dog #&quot; + dogNumber);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出,<code>Vector</code> 的使用是非常简单的：先创建一个,再用 <code>addElement()</code>置入对象,以后用 <code>elementAt()</code>取得那些对象(注意 <code>Vector</code> 有一个 <code>size()</code>方法，可使我们知道已添加了多少个元素,以便防止误超边界,造成违例错误)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Cat</code> 和 <code>Dog</code> 类都非常浅显——除了都是“对象”之外,它们并无特别之处(倘若不明确指出从什么类继承,就默认为从 <strong>Object</strong> 继承)。所以我们不仅能用 <code>Vector</code> 方法将 <code>Cat</code> 对象置入这个集合,也能添加 <code>Dog</code> 对象，同时不会在编译期和运行期得到任何出错提示。用Vector 方法<code>elementAt()</code>获取原本认为是<code>Cat</code> 的对象时,实际获得的是指向一个<strong>Object</strong> 的引用,必须将那个对象转型为<code>Cat</code>。</p>
<h3 id="15-2、迭代器-Iterator"><a href="#15-2、迭代器-Iterator" class="headerlink" title="15.2、迭代器 Iterator"></a><a id="152">15.2、迭代器 Iterator</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Vector</strong>有一个缺陷：需要事先知道集合的准确类型,否则无法使用。乍看来,这一点似乎没什么关系。但假若最开始决定使用<strong>Vector</strong>,后来在程序中又决定(考虑执行效率的原因)改变成一个 <strong>List</strong>(属于 Java1.2 集合库的一部分),这时又该如何做呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可利用“反复器”(<strong>Iterator</strong>)的概念达到这个目的。它可以是一个对象,作用是遍历一系列对象,并选择那个序列中的每个对象,同时不让客户程序员知道或关注那个序列的基础结构。此外,我们通常认为反复器是一种“轻量级”对象；也就是说,创建它只需付出极少的代价。但也正是由于这个原因,我们常发现反复器存在一些似乎很奇怪的限制。例如,有些反复器只能朝一个方向移动。<br>Java 的<strong>Enumeration</strong>(枚举,注释②)便是具有这些限制的一个反复器的例子。除下面这些外,不可再用它做其他任何事情：<br>(1) 用一个名为 <code>elements()</code>的方法要求集合为我们提供一个 Enumeration。我们首次调用它的 <code>nextElement()</code>时,这个Enumeration 会返回序列中的第一个元素。<br>(2) 用<code>nextElement()</code> 获得下一个对象。<br>(3) 用<code>hasMoreElements()</code>检查序列中是否还有更多的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package com.lizz.set;</div><div class="line">import java.util.Enumeration;</div><div class="line">import java.util.Vector;</div><div class="line">public class CatsAndDogs2 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Vector cats = new Vector();</div><div class="line">		for(int i = 0; i &lt; 7; i++)</div><div class="line">			cats.addElement(new Cat2(i));</div><div class="line">		 // Not a problem to add a dog to cats:</div><div class="line">		cats.addElement(new Dog2(7));</div><div class="line">		Enumeration e = cats.elements();</div><div class="line">		while(e.hasMoreElements())</div><div class="line">			((Cat2)e.nextElement()).print();</div><div class="line">		 // Dog is detected only at run-time</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Cat2 &#123;</div><div class="line">	private int catNumber;</div><div class="line">	Cat2(int i) &#123;</div><div class="line">		catNumber = i;</div><div class="line">	&#125;</div><div class="line">	void print() &#123;</div><div class="line">		System.out.println(&quot;Cat number &quot; +catNumber);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Dog2 &#123;</div><div class="line">	private int dogNumber;</div><div class="line">	Dog2(int i) &#123;</div><div class="line">		dogNumber = i;</div><div class="line">	&#125;</div><div class="line">	void print() &#123;</div><div class="line">		System.out.println(&quot;Dog number &quot; +dogNumber);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="15-3、BitSet"><a href="#15-3、BitSet" class="headerlink" title="15.3、BitSet"></a><a id="153">15.3、BitSet</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BitSet 实际是由“二进制位”构成的一个 Vector。如果希望高效率地保存大量“开－关”信息,就应使用BitSet。它只有从尺寸的角度看才有意义；如果希望的高效率的访问,那么它的速度会比使用一些固有类型的数组慢一些。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外,BitSet 的最小长度是一个长整数（Long）的长度：<strong>64 位</strong>。这意味着假如我们准备保存比这更小的数据,如 8 位数据,那么 BitSet 就显得浪费了。所以最好创建自己的类,用它容纳自己的标志位。</p>
<h3 id="15-4、Stack"><a href="#15-4、Stack" class="headerlink" title="15.4、Stack"></a><a id="154">15.4、Stack</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Stack</strong> 有时也可以称为“后入先出”（LIFO）集合。换言之,我们在堆栈里最后“压入”的东西将是以后第一个“弹出”的。和其他所有 Java 集合一样,我们压入和弹出的都是“对象”,所以必须对自己弹出的东西进行“造型”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack本身通过扩展Vector而来,而Vector本身是一个可增长的对象数组(a growable array of objects)那么这个数组的哪里作为Stack的栈顶,哪里作为Stack的栈底？<br>答案只能从源代码中寻找，jdk1.7：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123;</div><div class="line">    /**</div><div class="line">     * Creates an empty Stack.</div><div class="line">     */</div><div class="line">    public Stack() &#123;</div><div class="line">    &#125;</div><div class="line">    public E push(E item) &#123;</div><div class="line">        addElement(item);</div><div class="line">        return item;</div><div class="line">    &#125;</div><div class="line">    public synchronized E pop() &#123;</div><div class="line">        E       obj;</div><div class="line">        int     len = size();</div><div class="line">        obj = peek();</div><div class="line">        removeElementAt(len - 1);</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line">    public synchronized E peek() &#123;</div><div class="line">        int  len = size();</div><div class="line">        if (len == 0)</div><div class="line">            throw new EmptyStackException();</div><div class="line">        return elementAt(len - 1);</div><div class="line">    &#125;</div><div class="line">    public boolean empty() &#123;</div><div class="line">        return size() == 0;</div><div class="line">    &#125;</div><div class="line">    public synchronized int search(Object o) &#123;</div><div class="line">        int i = lastIndexOf(o);</div><div class="line">        if (i &gt;= 0) &#123;</div><div class="line">            return size() - i;</div><div class="line">        &#125;</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    /** use serialVersionUID from JDK 1.0.2 for interoperability */</div><div class="line">    private static final long serialVersionUID = 1224463164541339165L;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以前就一直听说栈是后入先出,但只停留于理论记忆,其实根本不明白这是什么意思。现在看了<code>Stack</code>的源码实现就有点豁然开朗了。内部的<code>push()</code>以及<code>pop()</code>跟js太像了,我估摸着后入先出的实现就是靠着<code>pop()</code>,该方法默认删除数组最后一个元素,而元素又是通过<code>push()</code>放进去的,默认是放在数组最后一个,所以一直都说<strong>栈是后入先出</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>栈顶其实就是数组最后一项。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意！！！</strong>Stack并不要求其中保存数据的唯一性,当Stack中有多个相同的<code>item</code>时,调用<code>search</code>方法,只返回与查找对象<code>equal</code>并且离栈顶最近的<code>item</code>与栈顶间距离(见源码中search方法说明)。</p>
</blockquote>
<h3 id="15-5、Hashtable"><a href="#15-5、Hashtable" class="headerlink" title="15.5、Hashtable"></a><a id="155">15.5、Hashtable</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Vector</strong> 允许我们用一个数字从一系列对象中作出选择,所以它实际是将数字同对象关联起来了。但假如需要通过一个对象来查找呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java 中,这个概念具体反映到抽象类 <strong>Dictionary</strong> 身上。该类的接口是非常直观的 <code>size()</code>告诉我们其中包含了多少元素；<code>isEmpty()</code>判断是否包含了元素(是则为 <code>true</code>)；<code>put(Object key, Object value)</code>添加一个值(我们希望的东西),并将其同一个键关联起来(想用于搜索它的东西)；<code>get(Object key)</code>获得与某个键对应的值；而<code>remove(Object Key)</code>用于从列表中删除“键－值”对。还可以使用枚举技术：<code>keys()</code>产生对键的一个枚举（Enumeration）；而 <code>elements()</code> 产生对所有值的一个枚举。这便是一个<strong>Dictionary</strong>(字典)的全部。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Dictionary</strong> 的实现过程并不麻烦。下面列出一种简单的方法,它使用了两个 <strong>Vector</strong>,一个用于容纳键,另一个用来容纳值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">package com.lizz.set;</div><div class="line">import java.util.Dictionary;</div><div class="line">import java.util.Enumeration;</div><div class="line">import java.util.Vector;</div><div class="line">public class AssocArray extends Dictionary &#123;</div><div class="line">	private Vector keys = new Vector();</div><div class="line">	private Vector values = new Vector();</div><div class="line">	public int size()&#123;</div><div class="line">		return keys.size();</div><div class="line">	&#125;</div><div class="line">	public boolean isEmpty() &#123;</div><div class="line">		return keys.isEmpty();</div><div class="line">	&#125;</div><div class="line">	public Object put(Object key, Object value) &#123;</div><div class="line">		keys.addElement(key);</div><div class="line">		values.addElement(value);</div><div class="line">		return key;</div><div class="line">	&#125;</div><div class="line">	public Object get(Object key) &#123;</div><div class="line">		int index = keys.indexOf(key);</div><div class="line">		if(index == -1) &#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">		return values.elementAt(index);</div><div class="line">	&#125;</div><div class="line">	public Object remove(Object key) &#123;</div><div class="line">		int index = keys.indexOf(key);</div><div class="line">		if(index == -1) &#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">		keys.removeElementAt(index);</div><div class="line">		Object returnvalue = values.elementAt(index);</div><div class="line">		values.removeElementAt(index);</div><div class="line">		return returnvalue;</div><div class="line">	&#125;</div><div class="line">	public Enumeration keys() &#123;</div><div class="line">		return keys.elements();</div><div class="line">	&#125;</div><div class="line">	public Enumeration elements() &#123;</div><div class="line">		return values.elements();</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		AssocArray aa = new AssocArray();</div><div class="line">		for(char c = &apos;a&apos;; c &lt; &apos;z&apos;; c++) &#123;</div><div class="line">			aa.put(String.valueOf(c), String.valueOf(c).toUpperCase());</div><div class="line">		&#125;</div><div class="line">		char[] ca = &#123;&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;&#125;;</div><div class="line">		for(int i = 0; i &lt; ca.length; i++) &#123;</div><div class="line">			System.out.println(&quot;Uppercase: &quot; + aa.get(String.valueOf(ca[i])));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>一个需要注意的示例</strong>：<br>SpringDetector.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">package com.lizz.set;</div><div class="line">import java.util.Hashtable;</div><div class="line">public class SpringDetector &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Hashtable hashtable = new Hashtable();</div><div class="line">		for(int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			hashtable.put(new Groundhog(i), new Prediction());</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;hashtable = &quot; + hashtable + &quot;\n&quot;);</div><div class="line">		System.out.println(&quot;Looking up prediction for groundhog #3:&quot;);</div><div class="line">		Groundhog groundhog = new Groundhog(3);</div><div class="line">		/*</div><div class="line">		 * Groundhog 是从通用的 Object 根类继承的（若当初未指定基础类，则所有类最终都是从Object 继承的）。</div><div class="line">		 * 事实上是用 Object 的 hashCode()方法生成每个对象的散列码，而且默认情况下只使用它的对象的地址。</div><div class="line">		 * 所以，Groundhog(3)的第一个实例并不会产生与Groundhog(3)第二个实例相等的散列码，而我们用第二个实例进行检索。</div><div class="line">		 * 大家或许认为此时要做的全部事情就是正确地覆盖 hashCode()。但这样做依然行不能，除非再做另一件事情：覆盖也属于Object 一部分的 equals()。</div><div class="line">		 * 当散列表试图判断我们的键是否等于表内的某个键时，就会用到这个方法。同样地，默认的 Object.equals()只是简单地比较对象地址，</div><div class="line">		 * 所以一个 Groundhog(3)并不等于另一个 Groundhog(3)。因此，为了在散列表中将自己的类作为键使用，必须同时覆盖 hashCode()和equals()，</div><div class="line">		 * 看示例 SpringDetector2</div><div class="line">		 */</div><div class="line">		if(hashtable.containsKey(groundhog)) &#123;</div><div class="line">			System.out.println((Prediction)hashtable.get(groundhog));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Groundhog &#123;</div><div class="line">	int ghNumber;</div><div class="line">	Groundhog(int n) &#123; </div><div class="line">		ghNumber = n; </div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Prediction &#123;</div><div class="line">	boolean shadow = Math.random() &gt; 0.5;</div><div class="line">	public String toString() &#123;</div><div class="line">		if(shadow)</div><div class="line">			return &quot;Six more weeks of Winter!&quot;;</div><div class="line">		else</div><div class="line">			return &quot;Early Spring!&quot;;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SpringDetector2.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">package com.lizz.set;</div><div class="line">import java.util.Hashtable;</div><div class="line">public class SpringDetector2 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Hashtable hashtable = new Hashtable();</div><div class="line">		for(int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			hashtable.put(new Groundhog2(i), new Prediction());</div><div class="line">		&#125;</div><div class="line">		System.out.println(&quot;hashtable = &quot; + hashtable + &quot;\n&quot;);</div><div class="line">		System.out.println(&quot;Looking up prediction for groundhog #3:&quot;);</div><div class="line">		Groundhog2 groundhog2 = new Groundhog2(3);</div><div class="line">		if(hashtable.containsKey(groundhog2)) &#123;</div><div class="line">			System.out.println((Prediction)hashtable.get(groundhog2));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Groundhog2 &#123;</div><div class="line">	int ghNumber;</div><div class="line">	Groundhog2(int n) &#123; </div><div class="line">		ghNumber = n;</div><div class="line">	&#125;</div><div class="line">	public int hashCode() &#123; </div><div class="line">		return ghNumber; </div><div class="line">	&#125;</div><div class="line">	public boolean equals(Object o) &#123;</div><div class="line">		return (o instanceof Groundhog2) &amp;&amp; (ghNumber == ((Groundhog2)o).ghNumber);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="15-6、排序"><a href="#15-6、排序" class="headerlink" title="15.6、排序"></a><a id="156">15.6、排序</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;书中的例子主要用到了<code>String.class</code>里面的<code>compareTo()</code>方法。那就看看源码吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private final char value[];</div><div class="line">public String(String original) &#123;</div><div class="line">        this.value = original.value;</div><div class="line">        this.hash = original.hash;</div><div class="line">&#125;</div><div class="line">public int compareTo(String anotherString) &#123;</div><div class="line">        int len1 = value.length;</div><div class="line">        int len2 = anotherString.value.length;</div><div class="line">        int lim = Math.min(len1, len2);</div><div class="line">        char v1[] = value;</div><div class="line">        char v2[] = anotherString.value;</div><div class="line">        int k = 0;</div><div class="line">        while (k &lt; lim) &#123;</div><div class="line">            char c1 = v1[k];</div><div class="line">            char c2 = v2[k];</div><div class="line">            if (c1 != c2) &#123;</div><div class="line">                return c1 - c2;</div><div class="line">            &#125;</div><div class="line">            k++;</div><div class="line">        &#125;</div><div class="line">        return len1 - len2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>compareTo()</code>接受一个<code>String</code>类型参数,由于涉及到了强转相当于<code>new String(&quot;参数&quot;)</code>调用了<code>String</code>的带<code>String</code>类型参数的构造器,这样<code>value</code>就有值了。而<code>value</code>初始化是一个<code>char</code>类型的数组,所以具有<code>length</code>属性。接下来比较调用<code>compareTo()</code>的<code>String</code>与传入的<code>String</code>参数长度并取较小的值。然后利用<code>while()</code>循环从数组下标为0开始进行比较,如果全部相等返回长度的差值<strong>0</strong>,如果数组元素中有一个不相等,则返回相应的<strong>ASCII码</strong>相减后的值(<strong>第一个参数大于第二个那就返回正整数,小于的话返回负整数</strong>)。</p>
<h3 id="15-7、新集合"><a href="#15-7、新集合" class="headerlink" title="15.7、新集合"></a><a id="157">15.7、新集合</a></h3><p><strong><a href="#123">返回目录</a></strong><br>新的集合库考虑到了“容纳自己对象”的问题,并将其分割成两个明确的概念：<br>(1) 集合(<code>Collection</code>)：一组单独的元素,通常应用了某种规则。在这里,一个 <code>List</code>(列表)必须按特定的顺序容纳元素,而一个<code>Set</code>(集)不可包含任何重复的元素。相反,“包”(<code>Bag</code>)的概念未在新的集合库中实现,因为“列表”已提供了类似的功能。<br>(2) 映射(<code>Map</code>)：一系列“键－值”对(这已在散列表身上得到了充分的体现)。从表面看,这似乎应该成为一个“键－值”对的“集合”,但假若试图按那种方式实现它,就会发现实现过程相当笨拙。这进一步证明了应该分离成单独的概念。另一方面，可以方便地查看 <code>Map</code> 的某个部分。只需创建一个集合,然后用它表示那一部分即可。这样一来,<code>Map</code> 就可以返回自己键的一个<code>Set</code>、一个包含自己值的<code>List</code> 或者包含自己“键－值”对的一个<code>List</code>。和数组相似,<code>Map</code> 可方便扩充到多个“维”,毋需涉及任何新概念。只需简单地在一个<code>Map</code> 里包含其他 <code>Map</code>(后者又可以包含更多的Map,以此类推)。</p>
<p><img src="../../../../images/jihe.png" alt=""></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这张图刚开始的时候可能让人有点儿摸不着头脑,但在通读了本章以后,相信大家会真正理解它实际只有三个集合组件：<strong>Map,List 和 Set</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虚线框代表“抽象”类,点线框代表“接口”,而实线框代表普通(实际)类。点线箭头表示一个特定的类准备实现一个接口(在抽象类的情况下,则是“部分”实现一个接口)。双线箭头表示一个类可生成箭头指向的那个类的对象。例如，任何集合都可以生成一个反复器(<code>Iterator</code>),而一个列表可以生成一个<code>ListIterator</code>(以及原始的反复器,因为列表是从集合继承的)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在观看这张示意图时,真正需要关心的只有位于最顶部的“接口”以及普通(实际)类——均用实线方框包围。通常需要生成实际类的一个对象,将其上溯造型为对应的接口。以后即可在代码的任何地方使用那个接口。<br>简单示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">package com.lizz.set;</div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.Collection;</div><div class="line">import java.util.Iterator;</div><div class="line">public class SimpleCollection &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Collection c = new ArrayList();</div><div class="line">		for(int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			c.add(Integer.toString(i));</div><div class="line">		&#125;</div><div class="line">		Iterator it = c.iterator();</div><div class="line">		while (it.hasNext()) &#123;</div><div class="line">			System.out.println(it.next());</div><div class="line">		&#125;</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查了下源码,发现<code>Collection</code>接口定义了<code>add()</code>以及<code>iterator()</code>等方法,而<code>ArrayList</code>实现了<code>List</code>接口,<code>List</code>接口继承自<code>Collection</code>,其实也就是<code>ArrayList</code>变相的实现了<code>Collection</code>接口里的方法。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述代码<code>while</code>循环用到了<code>hasNext()</code>,<code>Iterator</code>是一个接口,我查了下<code>ArrayList</code>以及<code>Collection</code>并没有明确继承或实现该接口,然后在<code>Collection</code>里的确找到了<code>iterator()</code>方法,然后又在<code>ArrayList</code>里找到了该方法的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public Iterator&lt;E&gt; iterator() &#123;</div><div class="line">	return new Itr();</div><div class="line">&#125;</div><div class="line">private class Itr implements Iterator&lt;E&gt; &#123;</div><div class="line">	int cursor;       // index of next element to return</div><div class="line">    int lastRet = -1; // index of last element returned; -1 if no such</div><div class="line">    int expectedModCount = modCount;</div><div class="line">    public boolean hasNext() &#123;</div><div class="line">        return cursor != size;</div><div class="line">    &#125;</div><div class="line">	...</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由源码可以看出,<code>iterator()</code>返回一个<code>Itr</code>类的实例,而该类实现了<code>Iterator</code>接口。在该类内部,它重写了或者说覆盖实现了<code>hasNext()</code>。</p>
<h3 id="15-7-1、removeAll-以及retainAll"><a href="#15-7-1、removeAll-以及retainAll" class="headerlink" title="15.7.1、removeAll()以及retainAll()"></a><a id="1571">15.7.1、removeAll()以及retainAll()</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<p>下面给出Thinking in Java示例中的部分代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Collection1 &#123;</div><div class="line">	public static Collection fill(Collection c, int start, int size) &#123;</div><div class="line">		for(int i = start; i &lt; start + size; i++) &#123;</div><div class="line">			c.add(Integer.toString(i));</div><div class="line">		&#125;</div><div class="line">		return c;</div><div class="line">	&#125;</div><div class="line">	public static Collection fill(Collection c) &#123;</div><div class="line">		return fill(c, 0, 10);</div><div class="line">	&#125;</div><div class="line">	public static Collection newCollection() &#123;</div><div class="line">		return fill(new ArrayList());</div><div class="line">	&#125;</div><div class="line">	public static Collection newCollection(int start, int size) &#123;</div><div class="line">		return fill(new ArrayList(), start, size);</div><div class="line">	&#125;</div><div class="line">	public static void print(Collection c) &#123;</div><div class="line">		for(Iterator x = c.iterator(); x.hasNext();) &#123;</div><div class="line">			System.out.println(x.next() + &quot; &quot;);</div><div class="line">		&#125;</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Collection c = newCollection();</div><div class="line">		c.add(&quot;ten&quot;);</div><div class="line">		c.add(&quot;eleven&quot;);</div><div class="line">		c.addAll(newCollection());</div><div class="line">		print(c);</div><div class="line">		Collection c2 = newCollection(5, 3);</div><div class="line">		c.retainAll(c2);</div><div class="line">		print(c);</div><div class="line">		c.removeAll(c2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述代码我在本地打印输出到了<code>c.retainAll(c2);</code>这一步有点不懂了。先是点进去查看了<code>ArrayList.class</code>里面的<code>retainAll()</code>方法的实现,发现它返回的是<code>batchRemove()</code>方法,看了下<code>batchRemove()</code>,一开始看不下去就去百度了。百度得知<code>retainAll()</code>是用来取<strong>交集</strong>的,结合控制台输出我知道这种解释是对的,但是百度还来了句<code>removeAll()</code>也调用了<code>batchRemove()</code>方法,这我就有点懵了。我就好奇他是怎么实现的呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面贴出相关的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">private static final int DEFAULT_CAPACITY = 10;</div><div class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line">transient Object[] elementData;</div><div class="line">private int size;</div><div class="line">protected transient int modCount = 0; // 这里是继承自AbstractList,并不是ArrayList内定义的</div><div class="line">public ArrayList() &#123;</div><div class="line">       this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">   &#125;</div><div class="line">public boolean add(E e) &#123;</div><div class="line">       ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">       elementData[size++] = e;</div><div class="line">       return true;</div><div class="line">   &#125;</div><div class="line">private void ensureCapacityInternal(int minCapacity) &#123;</div><div class="line">       if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">       &#125;</div><div class="line">       ensureExplicitCapacity(minCapacity);</div><div class="line">   &#125;</div><div class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</div><div class="line">       modCount++;</div><div class="line">       // overflow-conscious code</div><div class="line">       if (minCapacity - elementData.length &gt; 0)</div><div class="line">           grow(minCapacity);</div><div class="line">   &#125;</div><div class="line">private void grow(int minCapacity) &#123;</div><div class="line">       // overflow-conscious code</div><div class="line">       int oldCapacity = elementData.length;</div><div class="line">       int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</div><div class="line">       if (newCapacity - minCapacity &lt; 0)</div><div class="line">           newCapacity = minCapacity;</div><div class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">           newCapacity = hugeCapacity(minCapacity);</div><div class="line">       // minCapacity is usually close to size, so this is a win:</div><div class="line">       elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">   &#125;</div><div class="line">   private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</div><div class="line">       final Object[] elementData = this.elementData;</div><div class="line">       int r = 0, w = 0;</div><div class="line">       boolean modified = false;</div><div class="line">       try &#123;</div><div class="line">           for (; r &lt; size; r++)</div><div class="line">               if (c.contains(elementData[r]) == complement)</div><div class="line">                   elementData[w++] = elementData[r];</div><div class="line">       &#125; finally &#123;</div><div class="line">           // Preserve behavioral compatibility with AbstractCollection,</div><div class="line">           // even if c.contains() throws.</div><div class="line">           if (r != size) &#123;</div><div class="line">               System.arraycopy(elementData, r,</div><div class="line">                                elementData, w,</div><div class="line">                                size - r);</div><div class="line">               w += size - r;</div><div class="line">           &#125;</div><div class="line">           if (w != size) &#123;</div><div class="line">               // clear to let GC do its work</div><div class="line">               for (int i = w; i &lt; size; i++)</div><div class="line">                   elementData[i] = null;</div><div class="line">               modCount += size - w;</div><div class="line">               size = w;</div><div class="line">               modified = true;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return modified;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;研究<code>batchRemove()</code>内部的实现首先要知道<code>elementData</code>以及<code>size</code>,所以我把这两个变量初始化以及赋值相关的方法也贴出来了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合示例,<code>Collection c = newCollection();</code>这一步调用了<code>newCollection()</code>方法,而该方法内部返回了<code>fill(new ArrayList())</code>,我们知道<code>ArrayList()</code>其实实现了<code>Collection</code>接口,所以这一步调用的是<code>public static Collection fill(Collection c)</code>这个对应的<code>fill</code>方法。该方法内部又返回了<code>fill(c, 0, 10)</code>,这里其实是调用<code>public static Collection fill(Collection c, int start, int size)</code>这个对应的方法,然后利用该方法对<code>c</code>进行<code>add</code>元素并返回<code>c</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来针对每一步进行详解：</p>
<ol>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实示例中一开始的<code>Collection c = newCollection();</code>实际相当于<code>Collection c = new ArrayList()</code>,这一步实例化了<code>ArrayList</code>,那么同样的会调用它的构造方法。在构造方法里,给<code>elementData</code>初始化赋值为<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>(空对象集合)。</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;历经几步调用终于到了正主<code>public static Collection fill(Collection c, int start, int size)</code>,在该方法内使用了<code>add()</code>方法,也正是调用了<code>add()</code>,<code>elementData</code>以及<code>size</code>才开始赋值改变的。</li>
<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>add()</code>内的第一步就调用了<code>ensureCapacityInternal(size + 1)</code>,那么<code>size</code>从何而来呢？其实<code>size</code>在初始化时就定义了但是没有赋值,这里采用了默认值<strong>0</strong>。观察<code>ensureCapacityInternal()</code>方法,使用<code>minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity)</code>比较它们两个中较大的值并重新赋给<code>minCapacity</code>,<code>DEFAULT_CAPACITY</code>是常数设定为10比1大所以经过该方法后,<code>minCapacity</code>的值被改为<strong>10</strong>。随后又调用了<code>ensureExplicitCapacity()</code>方法。在<code>ensureExplicitCapacity()</code>里判断传过来的值是不是比<code>elementData</code>的长度大,是的话继续调用<code>grow(minCapacity)</code>。</li>
<li><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>grow()</code>方法是重点(容量增长算法)。摘抄自 <a href="https://www.cnblogs.com/aoguren/p/4765439.html" target="_blank" rel="external">https://www.cnblogs.com/aoguren/p/4765439.html</a></p>
<ul>
<li>先得到数组的旧容量,然后进行<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>,将<code>oldCapacity</code> 右移一位，其效果相当于<code>oldCapacity /2</code>,我们知道<strong>位运算的速度远远快于整除运算</strong>,整句运算式的结果就是将新容量更新为旧容量的<strong>1.5倍</strong>。</li>
<li>然后检查新容量是否大于最小需要容量,若还是小于最小需要容量,那么就把最小需要容量当作数组的新容量.</li>
<li>再检查新容量是否超出了<code>ArrayList</code>所定义的最大容量,若超出了,则调用<code>hugeCapacity()</code>来比较<code>minCapacity</code>和 <code>MAX_ARRAY_SIZE</code>,如果<code>minCapacity</code>大于最大容量,则新容量则为<code>ArrayList</code>定义的最大容量,否则,新容量大小则为 <code>minCapacity</code>。(在判断容量是否超过<code>MAX_ARRAY_SIZE</code>的值,<code>MAX_ARRAY_SIZE</code>值为<strong>Integer.MAX_VALUE - 8</strong>,比<code>int</code>的最大值小8,不知道为什设计,可能方便判断吧。如果已经超过,调用<code>hugeCapacity</code>方法检查容量的int值是不是已经溢出。)</li>
<li>最后确定了新的容量,就使用<code>Arrays.copyOf</code>方法来生成新的数组,<code>copyOf</code>也已经完成了将就的数据拷贝到新数组的工作。</li>
</ul>
</li>
<li><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面的方法,完成了<code>elementData</code>的重新赋值,接下来在看<code>batchRemove()</code>就容易很多了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结合示例,<code>batchRemove()</code>里面的<strong>c</strong>其实是我传进来的<strong>c2</strong>,循环遍历<strong>elementData</strong>,然后结合<code>complement</code>同时利用<code>contains()</code>来判断<strong>c</strong>中是否存在<code>elementData</code>中的元素,如果<code>complement</code>为true,同时<strong>c</strong>中也存在<code>elementData</code>中的元素,那么对<code>elementData</code>重新赋值(<strong>从下标为0开始</strong>)。最后通过<code>finally</code>判断<code>w</code>是不是和<code>size</code>相等,不等的话将<code>elementData</code>中多余的参数给清空掉。(<strong>w其实就是c的长度</strong>)</p>
</li>
</ol>
<h3 id="15-7-2、Lists"><a href="#15-7-2、Lists" class="headerlink" title="15.7.2、Lists"></a><a id="1572">15.7.2、Lists</a></h3><p><strong><a href="#123">返回目录</a></strong><br>包含：<strong>List、ArrayList、LinkedList</strong>。<br>ArrayList 允许我们快速访问元素,但在从列表中部插入和删除元素时,速度却嫌稍慢。<br>LinkedList 提供优化的顺序访问性能,同时可以高效率地在列表中部进行插入和删除操作。但在进行随机访问时,速度却相当慢,此时应换用 ArrayList。<br><img src="../../../../images/lists.png" alt=""></p>
<h3 id="15-7-3、Sets"><a href="#15-7-3、Sets" class="headerlink" title="15.7.3、Sets"></a><a id="1573">15.7.3、Sets</a></h3><p><strong><a href="#123">返回目录</a></strong><br>包含：<strong>Set、HashSet、TreeSet</strong>。<br>Set <strong>添加到 Set 的每个元素都必须是独一无二的；否则Set 就不会添加重复的元素</strong>。添加到 Set 里的对象必须定义<code>equals()</code>,从而建立对象的<strong>唯一性</strong>。Set 拥有与 Collection 完全相同的接口。一个 Set不能保证自己可按任何特定的顺序维持自己的元素。<br>HashSet 用于除非常小的以外的所有Set。对象也必须定义 <strong>hashCode()</strong><br>TreeSet 由一个“红黑树”后推得到的顺序 Set。<br><img src="../../../../images/sets.png" alt=""></p>
<h3 id="15-7-4、Maps"><a href="#15-7-4、Maps" class="headerlink" title="15.7.4、Maps"></a><a id="1574">15.7.4、Maps</a></h3><p><strong><a href="#123">返回目录</a></strong><br>包含：<strong>Map、HashMap、TreeMap</strong><br>HashMap 基于一个散列表实现（用它代替Hashtable）。针对“键－值”对的插入和检索,这种形式具有最稳定的性能。可通过构建器对这一性能进行调整,以便设置散列表的“能力”和“装载因子”。<a href="https://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="external">https://www.cnblogs.com/skywang12345/p/3310835.html</a><br>TreeMap 在一个“红－黑”树的基础上实现。查看键或者“键－值”对时,它们会按固定的顺序排列(取决于Comparable 或Comparator,稍后即会讲到)。TreeMap 最大的好处就是我们得到的是已排好序的结果。<br><img src="../../../../images/maps.png" alt=""></p>
<h3 id="15-7-5、Arrays-binarySearch"><a href="#15-7-5、Arrays-binarySearch" class="headerlink" title="15.7.5、Arrays.binarySearch"></a><a id="1575">15.7.5、Arrays.binarySearch</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;排序与搜索里面举了一个例子,用到了<code>sort</code>和<code>binarySearch</code>方法。<code>sort</code>我重开了一篇博客去研究它的源码实现,接下来的<code>binarySearch</code>方法一开始我没在意,直到我仔细研读书上的文字,发现它强调了：</p>
<blockquote>
<p><strong>与 binarySearch()有关的还有一个重要的警告：若在执行一次binarySearch()之前不调用 sort(),便会发生不可预测的行为,其中甚至包括无限循环。</strong></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这段话的意思无非就是使用<code>binarySearch</code>前必须先调用<code>sort</code>进行排序。这样就很有趣了,我便去看看它的源码实现：<br>Array.class:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static int binarySearch(byte[] a, byte key) &#123;</div><div class="line">    return binarySearch0(a, 0, a.length, key);</div><div class="line">&#125;</div><div class="line">private static int binarySearch0(byte[] a, int fromIndex, int toIndex, byte key) &#123;</div><div class="line">    int low = fromIndex;</div><div class="line">    int high = toIndex - 1;</div><div class="line">    while (low &lt;= high) &#123;</div><div class="line">        int mid = (low + high) &gt;&gt;&gt; 1;</div><div class="line">        byte midVal = a[mid];</div><div class="line">        if (midVal &lt; key)</div><div class="line">        	low = mid + 1;</div><div class="line">        else if (midVal &gt; key)</div><div class="line">            high = mid - 1;</div><div class="line">        else</div><div class="line">            return mid; // key found</div><div class="line">    &#125;</div><div class="line">    return -(low + 1);  // key not found.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Array1.java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class Array1 &#123;</div><div class="line">	static Random r = new Random();</div><div class="line">	static String ssource = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; + &quot;abcdefghijklmnopqrstuvwxyz&quot;;</div><div class="line">	static char[] src = ssource.toCharArray();</div><div class="line">	public static String randString(int length) &#123;</div><div class="line">		char[] buf = new char[length];</div><div class="line">		int rnd;</div><div class="line">		for(int i = 0; i &lt; length; i++) &#123;</div><div class="line">			rnd = Math.abs(r.nextInt()) % src.length;</div><div class="line">			buf[i] = src[rnd];</div><div class="line">		&#125;</div><div class="line">		return new String(buf);</div><div class="line">	&#125;</div><div class="line">	public static String[] randStrings(int length, int size) &#123;</div><div class="line">		String[] s = new String[size];</div><div class="line">		for(int i = 0; i &lt; size; i++) &#123;</div><div class="line">			s[i] = randString(length);</div><div class="line">		&#125;</div><div class="line">		return s;</div><div class="line">	&#125;</div><div class="line">	public static void print(byte[] b) &#123;</div><div class="line">		for(int i = 0; i &lt; b.length; i++) &#123;</div><div class="line">			System.out.println(b[i] + &quot; &quot;);</div><div class="line">		&#125;</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">	public static void print(String[] s) &#123;</div><div class="line">		for(int i = 0; i &lt; s.length; i++) &#123;</div><div class="line">			System.out.print(s[i] + &quot; &quot;);</div><div class="line">		&#125;	</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		byte[] b = new byte[15];</div><div class="line">		r.nextBytes(b);</div><div class="line">		print(b);</div><div class="line">		Arrays.sort(b);</div><div class="line">		print(b);</div><div class="line">		int loc = Arrays.binarySearch(b, b[10]);</div><div class="line">		System.out.println(&quot;Location of &quot; + b[10] + &quot; = &quot; + loc);</div><div class="line">		String[] s = randStrings(4, 10);</div><div class="line">		print(s);</div><div class="line">		Arrays.sort(s);</div><div class="line">		print(s);</div><div class="line">		loc = Arrays.binarySearch(s, s[4]);</div><div class="line">		System.out.println(&quot;Location of &quot; + s[4] + &quot; = &quot; + loc);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源码中有<code>(low + high) &gt;&gt;&gt; 1</code>这句代码,不明白的可以看：<a href="https://lizhongzhen11.github.io/2018/04/02/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E5%80%BC/" target="_blank" rel="external">https://lizhongzhen11.github.io/2018/04/02/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%9D%87%E5%80%BC/</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源码其实很简单,就是取下标平均值得到位于数组中间的值,然后拿该值和传进来的值比较,不断地去缩短范围,最终得到数组下标。但是,这种方法必须有一个前提：<strong>该数组是从小到大排列好的,因为它不断地用中间下标对应的值与传入的值进行比较,它认为,如果中间值比传入的小或者大,那么通过不断地缩短开始和结束下标范围就一定能找到传入值,这一切的前提都必须是排序好的。</strong></p>
<h3 id="16、java的I-O"><a href="#16、java的I-O" class="headerlink" title="16、java的I/O"></a><a id="16">16、java的I/O</a></h3><p><strong><a href="#123">返回目录</a></strong><br><strong>抄自：<a href="http://www.importnew.com/23708.html" target="_blank" rel="external">http://www.importnew.com/23708.html</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中I/O操作主要是指使用Java进行输入、输出操作。Java所有的I/O机制都是基于数据流进行输入输出,这些数据流表示了字符或者字节数据的流动序列。数据流是一组有序、有起点和终点的字节的数据序列。包括输入流和输出流。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;流序列中的数据既可以是未经加工的原始二进制数据,也可以是经一定编码处理后符合某种格式规定的特定数据。因此Java中的流分为两种：<br>1) 字节流：数据流中最小的数据单元是字节<br>2) 字符流：数据流中最小的数据单元是字符,Java中的字符是Unicode编码,一个字符占用两个字节。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java.io包中最重要的就是5个类和一个接口。5个类指的是<strong>File</strong>、<strong>OutputStream</strong>、<strong>InputStream</strong>、<strong>Writer</strong>、<strong>Reader</strong>;一个接口指的是<strong>Serializable</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java I/O主要包括如下3层次：</p>
<ol>
<li>流式部分——最主要的部分。如：OutputStream、InputStream、Writer、Reader等</li>
<li>非流式部分——如：File类、RandomAccessFile类和FileDescriptor等类</li>
<li>其他——文件读取部分的与安全相关的类,如：SerializablePermission类,以及与本地操作系统相关的文件系统的类,如：FileSystem类和Win32FileSystem类和WinNTFileSystem类。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要类如下：</p>
<ol>
<li>File(文件特征与管理)：用于文件或者目录的描述信息,例如生成新目录,修改文件名,删除文件,判断文件所在路径等。</li>
<li>InputStream(字节流，二进制格式操作)：抽象类,基于字节的输入操作,是所有输入流的父类。定义了所有输入流都具有的共同特征。</li>
<li>OutputStream(字节流，二进制格式操作)：抽象类。基于字节的输出操作。是所有输出流的父类。定义了所有输出流都具有的共同特征。</li>
<li>Reader(字符流，文本格式操作)：抽象类,基于字符的输入操作。</li>
<li>Writer(字符流，文本格式操作)：抽象类,基于字符的输出操作。</li>
<li>RandomAccessFile(随机文件操作)：它的功能丰富,可以从文件的任意位置进行存取(输入输出)操作。</li>
</ol>
<p><img src="../../../../images/io.png" alt=""><br><img src="../../../../images/io2.png" alt=""></p>
<h3 id="17、线程"><a href="#17、线程" class="headerlink" title="17、线程"></a><a id="17">17、线程</a></h3><p><strong><a href="#123">返回目录</a></strong><br><a href="http://www.cnblogs.com/xrq730/p/4850883.html" target="_blank" rel="external">http://www.cnblogs.com/xrq730/p/4850883.html</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TestThread.state</code>里面定义了6种状态,分别是：</p>
<ol>
<li>NEW：线程刚创建,还未启动</li>
<li>RUNNABLE：就绪状态。当调用了<code>start()</code>方法时就进入该状态。</li>
<li>BLOCKED：如果某一线程正在等待监视器锁,以便进入一个同步的块/方法,那么这个线程的状态就是阻塞BLOCKED</li>
<li>WAITING：某一线程因为调用不带超时的<code>Object</code>的<code>wait()</code>方法、不带超时的<code>Thread</code>的<code>join()</code>方法、<code>LockSupport</code>的<code>park()</code>方法,就会处于等待<code>WAITING</code>状态</li>
<li>TIMED_WAITING：某一线程因为调用带有指定正等待时间的<code>Object</code>的<code>wait()</code>方法、<code>Thread</code>的<code>join()</code>方法、<code>Thread</code>的<code>sleep()</code>方法、<code>LockSupport</code>的<code>parkNanos()</code>方法、<code>LockSupport</code>的<code>parkUntil()</code>方法，就会处于超时等待<code>TIMED_WAITING</code>状态</li>
<li>TERMINATED：线程调用终止或者<code>run()</code>方法执行结束后,线程即处于终止状态。处于终止状态的线程不具备继续运行的能力</li>
</ol>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/03/29/快速排序和冒泡排序/" title="快速排序和冒泡排序">快速排序和冒泡排序</a></h2>
                <p class="excerpt">
                
                
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最近空闲时间逛论坛发现,好多人在面试时问了排序算法,比如快速排序以及冒泡排序。我回想了下,依稀记得有什么for循环嵌套,然后就没了。这样可不好,不能工作了就忘了这些基础,会被淘汰的。所以又重新学习了下这两个算法,发现自己还是有
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-03-29T02:24:32.587Z" class="post-list__meta--date date">2018-03-29</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/03/29/快速排序和冒泡排序/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/03/16/TCP握手与挥手/" title="TCP三次握手与四次挥手">TCP三次握手与四次挥手</a></h2>
                <p class="excerpt">
                
                参考自：http://blog.csdn.net/qq598535550/article/details/52997218http://blog.csdn.net/guyuealian/article/details/52535294
声明&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-03-16T03:18:17.827Z" class="post-list__meta--date date">2018-03-16</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/03/16/TCP握手与挥手/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 lizhongzhen - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
