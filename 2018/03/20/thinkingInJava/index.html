<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Thinking in Java 学习笔记 | Ronaldo</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="一、目录
java基础数据类型
假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？
构造函数
垃圾收集
成员初始化
public, protected, default(friendly), private 对应的访问权限
final
方法过载与覆盖
抽象方法
接口
多重继承
多态
继承和 finalize()
构建器内部的多形性方法的行为




二、内容1">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Thinking in Java 学习笔记 | Ronaldo">
    <meta name="twitter:description" content="一、目录
java基础数据类型
假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？
构造函数
垃圾收集
成员初始化
public, protected, default(friendly), private 对应的访问权限
final
方法过载与覆盖
抽象方法
接口
多重继承
多态
继承和 finalize()
构建器内部的多形性方法的行为




二、内容1">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Thinking in Java 学习笔记 | Ronaldo">
    <meta property="og:description" content="一、目录
java基础数据类型
假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？
构造函数
垃圾收集
成员初始化
public, protected, default(friendly), private 对应的访问权限
final
方法过载与覆盖
抽象方法
接口
多重继承
多态
继承和 finalize()
构建器内部的多形性方法的行为




二、内容1">

    
    <meta name="author" content="lizhongzhen">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/logo.jpg">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Ronaldo" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2018/03/20/thinkingInJava/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/Daniel.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Ronaldo 的主页"><img src="/images/logo.jpg" width="80" alt="Ronaldo logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Ronaldo">Ronaldo</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Blogを読む" class="blog-button">Blog</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/3298783260/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" title="Weibo" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/lizhongzhen11" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-03-20T05:25:01.159Z" class="post-list__meta--date date">2018-03-20</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       No. <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Thinking in Java 学习笔记</h1>
  </header>

  <section class="post">
    <h2 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、<a id="123">目录</a></h2><ol>
<li><a href="#1">java基础数据类型</a></li>
<li><a href="#2">假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？</a></li>
<li><a href="#3">构造函数</a></li>
<li><a href="#4">垃圾收集</a></li>
<li><a href="#5">成员初始化</a></li>
<li><a href="#6">public, protected, default(friendly), private 对应的访问权限</a></li>
<li><a href="#7">final</a></li>
<li><a href="#8">方法过载与覆盖</a></li>
<li><a href="#9">抽象方法</a></li>
<li><a href="#10">接口</a></li>
<li><a href="#11">多重继承</a></li>
<li><a href="#12">多态</a></li>
<li><a href="#13">继承和 finalize()</a></li>
<li><a href="#14">构建器内部的多形性方法的行为</a></li>
<li><a href="#15"></a></li>
<li><a href="#16"></a></li>
<li><a href="#17"></a></li>
</ol>
<h2 id="二、内容"><a href="#二、内容" class="headerlink" title="二、内容"></a>二、内容</h2><h3 id="1、java基础数据类型"><a href="#1、java基础数据类型" class="headerlink" title="1、java基础数据类型"></a>1、<a id="1">java基础数据类型</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java基础数据类型：<strong>int, float, double, boolean, short, long, byte以及char</strong>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中,char类型是一个单一的 16 位 Unicode 字符。char类型用单引号表示也可以是整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cahr a = &apos;a&apos;; // 必须限定长度为一个字节。等效于 char a = 97; 因为&apos;a&apos;在ASCII码表里对应97.</div><div class="line">char b = &apos;中文&apos;;</div><div class="line">char c = 97;</div><div class="line">System.out.println(a == c); // true</div></pre></td></tr></table></figure></p>
<h3 id="2、假设一个值是29-7，我们把它强转成一个char，那么结果值到底是-30-还是29-呢？"><a href="#2、假设一个值是29-7，我们把它强转成一个char，那么结果值到底是-30-还是29-呢？" class="headerlink" title="2、假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？"></a>2、<a id="2">假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个 float 或 double 值造型成整数值后，总是将小数部分“砍掉”，不作任何进位处理。所以结果是29.</p>
<h3 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、<a id="3">构造函数</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造函数是在产生对象时被java系统<strong>自动调用</strong>的，我们不能在程序中像调用其他方法一样去调用构造方法（<strong>必须通过关键词new自动调用它</strong>）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造器属于一种较特殊的方法类型，因为它没有返回值。<br><strong>注意！</strong></p>
<ul>
<li>构造器里通过<code>this</code>调另一个构造器,只能调用一个,不能调用两个。</li>
<li>除构造器之外的方法不能调用构造器。</li>
</ul>
<h3 id="4、垃圾收集"><a href="#4、垃圾收集" class="headerlink" title="4、垃圾收集"></a>4、<a id="4">垃圾收集</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<ul>
<li>垃圾收集并不等于“破坏”！</li>
<li>我们的对象可能不会当作垃圾被收掉！</li>
<li>垃圾收集只跟内存有关！</li>
</ul>
<p>不必过多地使用<code>finalize()</code>。它并不是进行普通清除工作的理想场所。<code>finalize()</code>最有用处的地方之一是观察垃圾收集的过程。</p>
<h3 id="5、成员初始化"><a href="#5、成员初始化" class="headerlink" title="5、成员初始化"></a>5、<a id="5">成员初始化</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 尽自己的全力保证所有变量都能在使用前得到正确的初始化。若被定义成相对于一个方法的“局部”变量，这一保证就通过编译期的出错提示表现出来。因此，如果使用下述代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void f() &#123;</div><div class="line">    int i;</div><div class="line">    i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码会报错,提示未初始化。但是这样改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class InitialValues &#123;</div><div class="line">    private int i;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        InitialValues initialValues = new InitialValues();</div><div class="line">        System.out.println(initialValues.i);  // 0</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>能正常运行且<code>i</code>有一个初始值0.</p>
<ul>
<li><p>初始化顺序<br>  在一个类里,初始化的顺序是由变量在类内的定义顺序决定的。即使变量定义大量遍布于方法定义的中间,那些变量仍会在调用任何方法之前得到初始化——甚至在构建器调用之前。<br>  初始化的顺序是首先<strong>static</strong>(如果它们尚未由前一次对象创建过程初始化),接着是非static 对象,然后再构造器。</p>
</li>
<li><p>明确进行的静态初始化<br>  <strong><code>static</code>关键字定义的变量以及代码块在类初始化的时候就执行了,属于静态资源。</strong><br>  这里一开始我有一个误区：我一开始以为只要实例化一个对象就把该类初始化一遍,初始化一遍是不是也就把<code>static</code>关键字定义的内容也初始化一次。<br>  事实上,这种理解是错误的。<strong><code>static</code>修饰的内容在类第一次初始化后就当做静态资源暂存在java虚拟机上了,以后不管类初始化几次,都不会再对<code>static</code>修饰的内容初始化。</strong>做个比喻：一个类第一次初始化后就好比王者荣耀英雄刚进战场,把<code>static</code>修饰的内容赋为它的被动属性,被动属性英雄出场自带,其他属性升级(类被实例化)才能学到。<br>  所以下方代码执行后,明明实例化了两次<code>Cups</code>,但却只打印一次<code>Cup(1) Cup(2)</code>。因为第一次初始化后,<code>static</code>修饰的内容就不会再度执行了。</p>
</li>
</ul>
<p>看下面代码对比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class ExplicitStatic &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(&quot;Inside main()&quot;);</div><div class="line">		Cups.c1.f(99);</div><div class="line">	&#125;</div><div class="line">	static Cups x = new Cups();</div><div class="line">	static Cups y = new Cups();</div><div class="line">&#125;</div><div class="line">class Cup &#123;</div><div class="line">	public Cup(int marker) &#123;</div><div class="line">		System.out.println(&quot;Cup(&quot; + marker + &quot;)&quot;);</div><div class="line">	&#125;</div><div class="line">	void f(int marker) &#123;</div><div class="line">		System.out.println(&quot;f(&quot; + marker + &quot;)&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Cups &#123;</div><div class="line">	static Cup c1;</div><div class="line">	static Cup c2;</div><div class="line">	static &#123;</div><div class="line">		c1 = new Cup(1);</div><div class="line">		c2 = new Cup(2);</div><div class="line">	&#125;</div><div class="line">	public Cups() &#123;</div><div class="line">		System.out.println(&quot;Cups()&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码最终打印如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">Cups()</div><div class="line">Cups()</div><div class="line">Inside main()</div><div class="line">f(99)</div></pre></td></tr></table></figure></p>
<p>但是如果把<code>Cups</code>类里面的<code>static</code>代码块前的<code>static</code>去掉,打印如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">Cups()</div><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">Cups()</div><div class="line">Inside main()</div><div class="line">f(99)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果不进行<code>Cups</code>的实例化呢？<br>直接把<code>static Cups x = new Cups(); static Cups y = new Cups();</code>注释掉,会发现打印输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Inside main()</div><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">f(99)</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>初始化一个类并不仅仅靠实例化,通过 类.属性名 或者 类.方法也可以对类进行初始化！</strong></p>
<h3 id="6、public-protected-default-friendly-private-对应的访问权限"><a href="#6、public-protected-default-friendly-private-对应的访问权限" class="headerlink" title="6、public, protected, default(friendly), private 对应的访问权限"></a>6、<a id="6">public, protected, default(friendly), private 对应的访问权限</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类本身  同一包内  子孙类  不同包<br><strong>public</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>   <br><br><strong>protected</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>   <br><br><strong>default</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>   <br><br><strong>private</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong></p>
<h3 id="7、final"><a href="#7、final" class="headerlink" title="7、final"></a>7、<a id="7">final</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<ul>
<li><code>final</code>修饰的变量不能被重新赋值修改。</li>
<li><code>final</code>修饰的方法不能被继承类修改。</li>
<li><code>final</code>修饰的变量在定义时可以没有初始值,但是必须在构造器里赋值。</li>
<li><code>final</code>修饰的类不能被继承。</li>
<li><code>final</code>可以有效的关闭“动态绑定”。</li>
</ul>
<h3 id="8、方法过载与覆盖"><a href="#8、方法过载与覆盖" class="headerlink" title="8、方法过载与覆盖"></a>8、<a id="8">方法过载与覆盖</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<blockquote>
<p>“过载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。</p>
</blockquote>
<p>过载的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">	void play(int i) &#123;&#125;</div><div class="line">&#125;</div><div class="line">class C &#123;</div><div class="line">	C() &#123;&#125;</div><div class="line">&#125;</div><div class="line">class B extends A &#123;</div><div class="line">	void play(C c) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中,B继承了A,A里面有方法<code>play</code>不过参数是<code>int</code>型的,而B里面的<code>play</code>方法参数却是C类型的,这里并不是覆盖A类里面的<code>play</code>方法,而是新增了一个使用C类型参数的<code>play</code>方法。</p>
<h3 id="9、抽象方法"><a href="#9、抽象方法" class="headerlink" title="9、抽象方法"></a>9、<a id="9">抽象方法</a></h3><p><strong><a href="#123">返回目录</a></strong><br>语法：<code>abstract void X();</code><br>它属于一种不完整的方法，只含有一个声明，没有方法主体。<br>包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成<code>abstract</code>（抽象）。否则，编译器会向我们报告一条出错消息。</p>
<blockquote>
<p>当继承抽象类时,子类必须将抽象类的抽象方法全部显式的写出来,否则报错。</p>
</blockquote>
<h3 id="10、接口"><a href="#10、接口" class="headerlink" title="10、接口"></a>10、<a id="10">接口</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将接口视为一个“纯抽象”类。它允许创建者规定一个类的基本形式：方法名、自变量列表以及返回类型，但不规定方法主体。接口也包含了基本数据类型的数据成员，但它们都默认为static 和final。接口只提供一种形式，并不提供实施的细节。</p>
<h3 id="11、多重继承"><a href="#11、多重继承" class="headerlink" title="11、多重继承"></a>11、<a id="11">多重继承</a></h3><p><strong><a href="#123">返回目录</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于接口根本没有具体的实施细节——也就是说，没有存储空间与“接口”关联在一起——所以没有任何办法可以防止多个接口合并到一起。这一点是至关重要的，因为我们经常都需要表达这样一个意思：“x 从属于 a，也从属于 b，也从属于 c”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个衍生类中，我们并不一定要拥有一个抽象或具体（没有抽象方法）的基础类。如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于 <code>implements</code> 关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型。下面这个例子展示了一个“具体”类同几个接口合并的情况，它最终生成了一个新类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">interface CanFight &#123;</div><div class="line">	void fight();</div><div class="line">&#125;</div><div class="line">interface CanSwim &#123;</div><div class="line">	void swim();</div><div class="line">&#125;</div><div class="line">interface CanFly &#123;</div><div class="line">	void fly();</div><div class="line">&#125;</div><div class="line">class ActionCharacter &#123;</div><div class="line">	public void fight() &#123;&#125;</div><div class="line">&#125;</div><div class="line">class Hero extends ActionCharacter implements CanFight, CanSwim, CanFly &#123;</div><div class="line">	public void swim() &#123;&#125;</div><div class="line">	public void fly() &#123;&#125;</div><div class="line">&#125;</div><div class="line">public class Adventure &#123;</div><div class="line">	static void t(CanFight x) &#123; x.fight(); &#125;</div><div class="line">	static void u(CanSwim x) &#123; x.swim(); &#125;</div><div class="line">	static void v(CanFly x) &#123; x.fly(); &#125;</div><div class="line">	static void w(ActionCharacter x) &#123; x.fight(); &#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Hero i = new Hero();</div><div class="line"> 		t(i); // Treat it as a CanFight</div><div class="line"> 		u(i); // Treat it as a CanSwim</div><div class="line"> 		v(i); // Treat it as a CanFly</div><div class="line"> 		w(i); // Treat it as an ActionCharacter</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="12、多态"><a href="#12、多态" class="headerlink" title="12、多态"></a>12、<a id="12">多态</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<blockquote>
<p>三个必要条件：<strong>继承</strong>、<strong>重写</strong>、<strong>父类引用指向子类对象</strong>。<br>实现多态的技术称为动态绑定。是指在执行期间判断所引用对象的实际类型,根据其实际的类型调用其相应的方法。</p>
</blockquote>
<p><strong>以下内容来自知乎！</strong><br>直观的理解：<br>同一个方法名,但是参数不同,这叫方法重载。<code>Overload</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void foo(String str);</div><div class="line">void foo(int num);</div></pre></td></tr></table></figure></p>
<p>父类与子类有同样的方法名和参数,这叫方法覆盖。<code>Override</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Parent &#123;</div><div class="line">	void foo() &#123;</div><div class="line">		System.out.println(&quot;Parent foo()&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Child extends Parent &#123;</div><div class="line">	void foo() &#123;</div><div class="line">		System.out.println(&quot;Child foo()&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>父类引用指向子类对象,调用方法时会调用子类的实现,而不是父类的实现,这叫多态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Parent instance = new Child();</div><div class="line">instance.foo(); // 此处其实调用的是 Child 类里面的 foo()</div></pre></td></tr></table></figure></p>
<p>拓展深入理解下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Animal &#123;</div><div class="line">	int num = 10;</div><div class="line">	static int age = 20;</div><div class="line">	public void eat() &#123;</div><div class="line">		System.out.println(&quot;动物吃饭&quot;);</div><div class="line">	&#125;</div><div class="line">	public static void sleep() &#123;</div><div class="line">		System.out.println(&quot;动物在睡觉&quot;);</div><div class="line">	&#125;</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(&quot;动物在奔跑&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Cat extends Animal &#123;</div><div class="line">	int num = 80;</div><div class="line">	static int age = 90;</div><div class="line">	String name = &quot;tomCat&quot;;</div><div class="line">	public void eat() &#123;</div><div class="line">		System.out.println(&quot;猫吃饭&quot;);</div><div class="line">	&#125;</div><div class="line">	public static void sleep() &#123;</div><div class="line">		System.out.println(&quot;猫在睡觉&quot;);</div><div class="line">	&#125;</div><div class="line">	public void catchMouse() &#123;</div><div class="line">		System.out.println(&quot;猫在抓老鼠&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试类Demo_Test1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Demo_Test1 &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Animal am = new Cat();</div><div class="line">		am.eat();</div><div class="line">		am.sleep();</div><div class="line">		am.run();</div><div class="line">//		am.catchMouse();  报错,Animal类里没有这个方法。</div><div class="line">//		System.out.println(am.name);  报错</div><div class="line">		System.out.println(am.num);</div><div class="line">		System.out.println(am.age);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 打印输出</div><div class="line">猫吃饭</div><div class="line">动物在睡觉</div><div class="line">动物在奔跑</div><div class="line">10</div><div class="line">20</div></pre></td></tr></table></figure></p>
<p>由上述例子可以看出：</p>
<ul>
<li>子类 <code>Cat</code> 中重写或者覆盖了父类 <code>Animal</code> 中的 <code>eat()</code>,所以打印输出了 猫吃饭。</li>
<li>子类 <code>Cat</code> 中虽然也重新对父类<code>Animal</code>中的 <code>sleep()</code> 进行重写,但是输出发现并未覆盖掉父类的方法。仔细观察发现,<strong>该方法是静态的,不会被覆盖</strong>。</li>
<li>子类 <code>Cat</code> 中虽然也重新对父类<code>Animal</code>中的 <code>num</code> 和 <code>age</code> 进行赋值期望覆盖父类,但是由于<code>age</code>也是静态的,依旧不能被覆盖。<strong>不过需要着重关注的是<code>num</code>,该变量不是静态的,也没有用<code>final</code>修饰,却依然未被覆盖</strong>。</li>
<li>上述代码中有两处报错,分别是子类定义的<code>name</code>变量以及<code>catchMouse()</code>！<br>对这个现象的理解应该是,<code>am</code>声明时是<code>Animal</code>类型,虽然给它赋值了<code>Cat</code>类型并没有报错,但那是因为<code>Cat</code>类型继承自<code>Animal</code>类型,所以可以赋值。<strong>不过,<code>am</code>的本质依然是<code>Animal</code>类型而不是<code>Cat</code>类型,<code>Animal</code>类型中并没有<code>name</code>变量以及<code>catchMouse()</code>,所以会报错</strong>。</li>
</ul>
<blockquote>
<p>那么可以总结出多态成员访问的特点：<br><strong>成员变量</strong><br>编译看左边(父类),运行也看左边(父类)。<br><strong>成员方法</strong><br>编译看左边(父类),运行却看右边(子类)。动态绑定。<br><strong>静态方法</strong><br>编译看左边(父类),运行也看左边(父类)。<br><strong>只有非静态成员的方法,编译才看左边,运行看右边。</strong></p>
</blockquote>
<p>从上述例子可以看出,多态有一个弊端即无法访问子类定义的方法和变量。<br>怎么才能访问子类的方法和变量呢？<br><strong>强转</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Cat ct = (Cat)am;</div><div class="line">ct.catchMouse();</div><div class="line">System.out.println(ct.name);</div></pre></td></tr></table></figure></p>
<h3 id="13、继承和-finalize"><a href="#13、继承和-finalize" class="headerlink" title="13、继承和 finalize()"></a>13、<a id="13">继承和 finalize()</a></h3><p><strong><a href="#123">返回目录</a></strong><br>看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">package com.lizz.finalize;</div><div class="line">public class Frog extends Amphibian &#123;</div><div class="line">	Frog() &#123;</div><div class="line">		System.out.println(&quot;Frog()&quot;);</div><div class="line">	&#125;</div><div class="line">	protected void finalize() &#123;</div><div class="line">		System.out.println(&quot;Frog finalize&quot;);</div><div class="line">		if(DoBaseFinalization.flag) &#123;</div><div class="line">			try &#123;</div><div class="line">				super.finalize();</div><div class="line">			&#125; catch (Throwable e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		if(args.length != 0 &amp;&amp; args[0].equals(&quot;finalize&quot;)) &#123;</div><div class="line">			DoBaseFinalization.flag = true;</div><div class="line">		&#125; else &#123;</div><div class="line">			System.out.println(&quot;not finalizing bases&quot;);</div><div class="line">		&#125;</div><div class="line">		new Frog();</div><div class="line">		System.out.println(&quot;bye!&quot;);</div><div class="line">		System.runFinalizersOnExit(true);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class DoBaseFinalization &#123;</div><div class="line">	public static boolean flag = false;</div><div class="line">&#125;</div><div class="line">class Characteristic &#123;</div><div class="line">	String s;</div><div class="line">	Characteristic(String c) &#123;</div><div class="line">		s = c;</div><div class="line">		System.out.println(&quot;Creating Character &quot; + s);</div><div class="line">	&#125;</div><div class="line">	protected void finalize() &#123;</div><div class="line">		System.out.println(&quot;finalizing Characteristic &quot; + s);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class LivingCreature &#123;</div><div class="line">	Characteristic p = new Characteristic(&quot;is alive&quot;);</div><div class="line">	LivingCreature() &#123;</div><div class="line">		System.out.println(&quot;LivingCreature()&quot;);</div><div class="line">	&#125;</div><div class="line">	protected void finalize() &#123;</div><div class="line">		System.out.println(&quot;LivingCreature finalize&quot;);</div><div class="line">		if(DoBaseFinalization.flag) &#123;</div><div class="line">			try &#123;</div><div class="line">				super.finalize();</div><div class="line">			&#125; catch (Throwable e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Animal extends LivingCreature &#123;</div><div class="line">	Characteristic p = new Characteristic(&quot;has heart&quot;);</div><div class="line">	Animal() &#123;</div><div class="line">		System.out.println(&quot;Animal()&quot;);</div><div class="line">	&#125;</div><div class="line">	protected void finalize() &#123;</div><div class="line">		System.out.println(&quot;Animal finalize&quot;);</div><div class="line">		if(DoBaseFinalization.flag) &#123;</div><div class="line">			try &#123;</div><div class="line">				super.finalize();</div><div class="line">			&#125; catch (Throwable e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Amphibian extends Animal &#123;</div><div class="line">	Characteristic p = new Characteristic(&quot;can live in water&quot;);</div><div class="line">	Amphibian() &#123;</div><div class="line">		System.out.println(&quot;Amphibian()&quot;);</div><div class="line">	&#125;</div><div class="line">	protected void finalize() &#123;</div><div class="line">		System.out.println(&quot;Amphibian finalize&quot;);</div><div class="line">		if(DoBaseFinalization.flag) &#123;</div><div class="line">			try &#123;</div><div class="line">				super.finalize();</div><div class="line">			&#125; catch (Throwable e) &#123;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 打印输出：</div><div class="line">not finalizing bases</div><div class="line">Creating Character is alive</div><div class="line">LivingCreature()</div><div class="line">Creating Character has heart</div><div class="line">Animal()</div><div class="line">Creating Character can live in water</div><div class="line">Amphibian()</div><div class="line">Frog()</div><div class="line">bye!</div><div class="line">finalizing Characteristic can live in water</div><div class="line">finalizing Characteristic has heart</div><div class="line">finalizing Characteristic is alive</div><div class="line">Frog finalize</div></pre></td></tr></table></figure></p>
<blockquote>
<p>仔细观察代码和后4个输出,发现输出顺序是从<strong>最低级的子类不断往上一直到基础类</strong>,也就是说<code>finalize()</code>是从最下面的子类不断向上调用的。<br>按照与 C++ 中用于“破坏器”相同的形式，我们应该首先执行衍生类的收尾，再是基础类的收尾。这是由于衍生类的收尾可能调用基础类中相同的方法，要求基础类组件仍然处于活动状态。因此，必须提前将它们清除（破坏）。</p>
</blockquote>
<h3 id="14、构建器内部的多形性方法的行为"><a href="#14、构建器内部的多形性方法的行为" class="headerlink" title="14、构建器内部的多形性方法的行为"></a>14、<a id="14">构建器内部的多形性方法的行为</a></h3><p><strong><a href="#123">返回目录</a></strong></p>
<blockquote>
<p>设计构建器时一个特别有效的规则是：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用尽可能简单的方法使对象进入就绪状态；如果可能,避免调用任何方法。在构建器内唯一能够安全调用的是在基础类中具有<code>final</code> 属性的那些方法(也适用于<code>private</code>方法,它们自动具有<code>final</code> 属性)。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>若调用构建器内部一个动态绑定的方法,会使用那个方法被覆盖的定义</strong>。然而,产生的效果可能并不如我们所愿,而且可能造成一些难于发现的程序错误。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从概念上讲,构建器的职责是让对象实际进入存在状态。<strong>在任何构建器内部,整个对象可能只是得到部分组织——我们只知道基础类对象已得到初始化,但却不知道哪些类已经继承。然而,一个动态绑定的方法调用却会在分级结构里“向前”或者“向外”前进。它调用位于衍生类里的一个方法。</strong>如果在构建器内部做这件事情,那么对于调用的方法,它要操纵的成员可能尚未得到正确的初始化——这显然不是我们所希望的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.lizz.polymorphism;</div><div class="line">public class PolyConstructors &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new RoundGlyph(5);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">abstract class Glyph &#123;</div><div class="line">	abstract void draw();</div><div class="line">	Glyph() &#123;</div><div class="line">		System.out.println(&quot;Glyph() before draw()&quot;);</div><div class="line">		draw();</div><div class="line">		System.out.println(&quot;Glyph() after draw()&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class RoundGlyph extends Glyph &#123;</div><div class="line">	int radius = 1;</div><div class="line">	RoundGlyph(int i) &#123;</div><div class="line">		radius = i;</div><div class="line">		System.out.println(&quot;RoundGlyph.RoundGlyph(), radius = &quot; + radius);</div><div class="line">	&#125;</div><div class="line">	void draw() &#123;</div><div class="line">		System.out.println(&quot;RoundGlyph.drwa(), radius = &quot; + radius);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">// 打印输出：</div><div class="line">Glyph() before draw()</div><div class="line">RoundGlyph.drwa(), radius = 0</div><div class="line">Glyph() after draw()</div><div class="line">RoundGlyph.RoundGlyph(), radius = 5</div></pre></td></tr></table></figure>
<p>仔细观察上述代码以及输出,发现<code>Glyph</code>初始化调用构造器时,其内部的<code>draw()</code>并没有定义方法主体但是却打印输出了<code>RoundGlyph</code>类内部重写的<code>draw()</code>方法。<br>初始化的实际过程：</p>
<ul>
<li>在采取其他任何操作之前，为对象分配的存储空间初始化成二进制零。</li>
<li>就象前面叙述的那样,调用基础类构建器。此时,被覆盖的<code>draw()</code>方法会得到调用(的确是在 <code>RoundGlyph</code> 构建器调用之前),此时会发现 <code>radius</code> 的值为 0,这是由于步骤(1)造成的。</li>
<li>按照原先声明的顺序调用成员初始化代码。</li>
<li>调用衍生类构建器的主体。</li>
</ul>

  </section>

</article>

<section class="read-more">
           
    
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">以前の記事</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/03/16/TCP握手与挥手/" title="TCP三次握手与四次挥手">TCP三次握手与四次挥手</a></h2>
                <p class="excerpt">
                
                参考自：http://blog.csdn.net/qq598535550/article/details/52997218http://blog.csdn.net/guyuealian/article/details/52535294
声明&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-03-16T03:18:17.827Z" class="post-list__meta--date date">2018-03-16</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/03/16/TCP握手与挥手/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 lizhongzhen - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
