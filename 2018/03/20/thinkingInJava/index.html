<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Thinking in Java 学习笔记 | Ronaldo</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="1、java基础数据类型&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;java基础数据类型：int, float, double, boolean, short, long, byte以及char.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;其中,char类型是一个单一的 16 位 Unicode 字符。char类型用单引号表示也可以是整数。1">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Thinking in Java 学习笔记 | Ronaldo">
    <meta name="twitter:description" content="1、java基础数据类型&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;java基础数据类型：int, float, double, boolean, short, long, byte以及char.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;其中,char类型是一个单一的 16 位 Unicode 字符。char类型用单引号表示也可以是整数。1">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Thinking in Java 学习笔记 | Ronaldo">
    <meta property="og:description" content="1、java基础数据类型&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;java基础数据类型：int, float, double, boolean, short, long, byte以及char.&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;其中,char类型是一个单一的 16 位 Unicode 字符。char类型用单引号表示也可以是整数。1">

    
    <meta name="author" content="lizhongzhen">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/logo.jpg">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Ronaldo" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2018/03/20/thinkingInJava/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/Daniel.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Ronaldo 的主页"><img src="/images/logo.jpg" width="80" alt="Ronaldo logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Ronaldo">Ronaldo</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/3298783260/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" title="Weibo" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/lizhongzhen11" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-03-20T05:25:01.159Z" class="post-list__meta--date date">2018-03-20</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Thinking in Java 学习笔记</h1>
  </header>

  <section class="post">
    <h3 id="1、java基础数据类型"><a href="#1、java基础数据类型" class="headerlink" title="1、java基础数据类型"></a>1、java基础数据类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java基础数据类型：<strong>int, float, double, boolean, short, long, byte以及char</strong>.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中,char类型是一个单一的 16 位 Unicode 字符。char类型用单引号表示也可以是整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cahr a = &apos;a&apos;; // 必须限定长度为一个字节。等效于 char a = 97; 因为&apos;a&apos;在ASCII码表里对应97.</div><div class="line">char b = &apos;中文&apos;;</div><div class="line">char c = 97;</div><div class="line">System.out.println(a == c); // true</div></pre></td></tr></table></figure></p>
<h3 id="2、假设一个值是29-7，我们把它强转成一个char，那么结果值到底是-30-还是29-呢？"><a href="#2、假设一个值是29-7，我们把它强转成一个char，那么结果值到底是-30-还是29-呢？" class="headerlink" title="2、假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？"></a>2、假设一个值是29.7，我们把它强转成一个char，那么结果值到底是 30 还是29 呢？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将一个 float 或 double 值造型成整数值后，总是将小数部分“砍掉”，不作任何进位处理。所以结果是29.</p>
<h3 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造函数是在产生对象时被java系统<strong>自动调用</strong>的，我们不能在程序中像调用其他方法一样去调用构造方法（<strong>必须通过关键词new自动调用它</strong>）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造器属于一种较特殊的方法类型，因为它没有返回值。<br><strong>注意！</strong></p>
<ul>
<li>构造器里通过<code>this</code>调另一个构造器,只能调用一个,不能调用两个。</li>
<li>除构造器之外的方法不能调用构造器。</li>
</ul>
<h3 id="4、垃圾收集"><a href="#4、垃圾收集" class="headerlink" title="4、垃圾收集"></a>4、垃圾收集</h3><ul>
<li>垃圾收集并不等于“破坏”！</li>
<li>我们的对象可能不会当作垃圾被收掉！</li>
<li>垃圾收集只跟内存有关！</li>
</ul>
<p>不必过多地使用<code>finalize()</code>。它并不是进行普通清除工作的理想场所。<code>finalize()</code>最有用处的地方之一是观察垃圾收集的过程。</p>
<h3 id="5、成员初始化"><a href="#5、成员初始化" class="headerlink" title="5、成员初始化"></a>5、成员初始化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 尽自己的全力保证所有变量都能在使用前得到正确的初始化。若被定义成相对于一个方法的“局部”变量，这一保证就通过编译期的出错提示表现出来。因此，如果使用下述代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void f() &#123;</div><div class="line">    int i;</div><div class="line">    i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码会报错,提示未初始化。但是这样改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class InitialValues &#123;</div><div class="line">    private int i;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        InitialValues initialValues = new InitialValues();</div><div class="line">        System.out.println(initialValues.i);  // 0</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>能正常运行且<code>i</code>有一个初始值0.</p>
<ul>
<li><p>初始化顺序<br>  在一个类里,初始化的顺序是由变量在类内的定义顺序决定的。即使变量定义大量遍布于方法定义的中间,那些变量仍会在调用任何方法之前得到初始化——甚至在构建器调用之前。<br>  初始化的顺序是首先<strong>static</strong>(如果它们尚未由前一次对象创建过程初始化),接着是非static 对象,然后再构造器。</p>
</li>
<li><p>明确进行的静态初始化<br>  <strong><code>static</code>关键字定义的变量以及代码块在类初始化的时候就执行了,属于静态资源。</strong><br>  这里一开始我有一个误区：我一开始以为只要实例化一个对象就把该类初始化一遍,初始化一遍是不是也就把<code>static</code>关键字定义的内容也初始化一次。<br>  事实上,这种理解是错误的。<strong><code>static</code>修饰的内容在类第一次初始化后就当做静态资源暂存在java虚拟机上了,以后不管类初始化几次,都不会再对<code>static</code>修饰的内容初始化。</strong>做个比喻：一个类第一次初始化后就好比王者荣耀英雄刚进战场,把<code>static</code>修饰的内容赋为它的被动属性,被动属性英雄出场自带,其他属性升级(类被实例化)才能学到。<br>  所以下方代码执行后,明明实例化了两次<code>Cups</code>,但却只打印一次<code>Cup(1) Cup(2)</code>。因为第一次初始化后,<code>static</code>修饰的内容就不会再度执行了。</p>
</li>
</ul>
<p>看下面代码对比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class ExplicitStatic &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(&quot;Inside main()&quot;);</div><div class="line">		Cups.c1.f(99);</div><div class="line">	&#125;</div><div class="line">	static Cups x = new Cups();</div><div class="line">	static Cups y = new Cups();</div><div class="line">&#125;</div><div class="line">class Cup &#123;</div><div class="line">	public Cup(int marker) &#123;</div><div class="line">		System.out.println(&quot;Cup(&quot; + marker + &quot;)&quot;);</div><div class="line">	&#125;</div><div class="line">	void f(int marker) &#123;</div><div class="line">		System.out.println(&quot;f(&quot; + marker + &quot;)&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Cups &#123;</div><div class="line">	static Cup c1;</div><div class="line">	static Cup c2;</div><div class="line">	static &#123;</div><div class="line">		c1 = new Cup(1);</div><div class="line">		c2 = new Cup(2);</div><div class="line">	&#125;</div><div class="line">	public Cups() &#123;</div><div class="line">		System.out.println(&quot;Cups()&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码最终打印如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">Cups()</div><div class="line">Cups()</div><div class="line">Inside main()</div><div class="line">f(99)</div></pre></td></tr></table></figure></p>
<p>但是如果把<code>Cups</code>类里面的<code>static</code>代码块前的<code>static</code>去掉,打印如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">Cups()</div><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">Cups()</div><div class="line">Inside main()</div><div class="line">f(99)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果不进行<code>Cups</code>的实例化呢？<br>直接把<code>static Cups x = new Cups(); static Cups y = new Cups();</code>注释掉,会发现打印输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Inside main()</div><div class="line">Cup(1)</div><div class="line">Cup(2)</div><div class="line">f(99)</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>初始化一个类并不仅仅靠实例化,通过 类.属性名 或者 类.方法也可以对类进行初始化！</strong></p>
<h3 id="6、public-protected-default-friendly-private-对应的访问权限"><a href="#6、public-protected-default-friendly-private-对应的访问权限" class="headerlink" title="6、public, protected, default(friendly), private 对应的访问权限"></a>6、public, protected, default(friendly), private 对应的访问权限</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类本身  同一包内  子孙类  不同包<br><strong>public</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>   <br><br><strong>protected</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>   <br><br><strong>default</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>   <br><br><strong>private</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>√</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>×</strong></p>
<h3 id="7、final"><a href="#7、final" class="headerlink" title="7、final"></a>7、final</h3><ul>
<li><code>final</code>修饰的变量不能被重新赋值修改。</li>
<li><code>final</code>修饰的方法不能被继承类修改。</li>
<li><code>final</code>修饰的变量在定义时可以没有初始值,但是必须在构造器里赋值。</li>
<li><code>final</code>修饰的类不能被继承。</li>
<li><code>final</code>可以有效的关闭“动态绑定”。</li>
</ul>
<h3 id="8、方法过载与覆盖"><a href="#8、方法过载与覆盖" class="headerlink" title="8、方法过载与覆盖"></a>8、方法过载与覆盖</h3><blockquote>
<p>“过载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。</p>
</blockquote>
<p>过载的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">	void play(int i) &#123;&#125;</div><div class="line">&#125;</div><div class="line">class C &#123;</div><div class="line">	C() &#123;&#125;</div><div class="line">&#125;</div><div class="line">class B extends A &#123;</div><div class="line">	void play(C c) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中,B继承了A,A里面有方法<code>play</code>不过参数是<code>int</code>型的,而B里面的<code>play</code>方法参数却是C类型的,这里并不是覆盖A类里面的<code>play</code>方法,而是新增了一个使用C类型参数的<code>play</code>方法。</p>
<h3 id="9、抽象方法"><a href="#9、抽象方法" class="headerlink" title="9、抽象方法"></a>9、抽象方法</h3><p>语法：<code>abstract void X();</code><br>它属于一种不完整的方法，只含有一个声明，没有方法主体。<br>包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成<code>abstract</code>（抽象）。否则，编译器会向我们报告一条出错消息。</p>
<blockquote>
<p>当继承抽象类时,子类必须将抽象类的抽象方法全部显式的写出来,否则报错。</p>
</blockquote>
<h3 id="10、接口"><a href="#10、接口" class="headerlink" title="10、接口"></a>10、接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将接口视为一个“纯抽象”类。它允许创建者规定一个类的基本形式：方法名、自变量列表以及返回类型，但不规定方法主体。接口也包含了基本数据类型的数据成员，但它们都默认为static 和final。接口只提供一种形式，并不提供实施的细节。</p>
<h3 id="11、多重继承"><a href="#11、多重继承" class="headerlink" title="11、多重继承"></a>11、多重继承</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于接口根本没有具体的实施细节——也就是说，没有存储空间与“接口”关联在一起——所以没有任何办法可以防止多个接口合并到一起。这一点是至关重要的，因为我们经常都需要表达这样一个意思：“x 从属于 a，也从属于 b，也从属于 c”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个衍生类中，我们并不一定要拥有一个抽象或具体（没有抽象方法）的基础类。如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于 <code>implements</code> 关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型。下面这个例子展示了一个“具体”类同几个接口合并的情况，它最终生成了一个新类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import java.util.*;</div><div class="line">interface CanFight &#123;</div><div class="line">	void fight();</div><div class="line">&#125;</div><div class="line">interface CanSwim &#123;</div><div class="line">	void swim();</div><div class="line">&#125;</div><div class="line">interface CanFly &#123;</div><div class="line">	void fly();</div><div class="line">&#125;</div><div class="line">class ActionCharacter &#123;</div><div class="line">	public void fight() &#123;&#125;</div><div class="line">&#125;</div><div class="line">class Hero extends ActionCharacter implements CanFight, CanSwim, CanFly &#123;</div><div class="line">	public void swim() &#123;&#125;</div><div class="line">	public void fly() &#123;&#125;</div><div class="line">&#125;</div><div class="line">public class Adventure &#123;</div><div class="line">	static void t(CanFight x) &#123; x.fight(); &#125;</div><div class="line">	static void u(CanSwim x) &#123; x.swim(); &#125;</div><div class="line">	static void v(CanFly x) &#123; x.fly(); &#125;</div><div class="line">	static void w(ActionCharacter x) &#123; x.fight(); &#125;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Hero i = new Hero();</div><div class="line"> 		t(i); // Treat it as a CanFight</div><div class="line"> 		u(i); // Treat it as a CanSwim</div><div class="line"> 		v(i); // Treat it as a CanFly</div><div class="line"> 		w(i); // Treat it as an ActionCharacter</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

  </section>

</article>

<section class="read-more">
           
    
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/03/16/TCP握手与挥手/" title="TCP三次握手与四次挥手">TCP三次握手与四次挥手</a></h2>
                <p class="excerpt">
                
                参考自：http://blog.csdn.net/qq598535550/article/details/52997218http://blog.csdn.net/guyuealian/article/details/52535294
声明&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-03-16T03:18:17.827Z" class="post-list__meta--date date">2018-03-16</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/03/16/TCP握手与挥手/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 lizhongzhen - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
