<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>管中窥豹：HashMap原理学习以及jdk1.8版本中源码的变更 | Ronaldo</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="学习自https://www.cnblogs.com/skywang12345/p/3310835.htmlhttps://blog.csdn.net/unscdf117/article/details/78729674?locationNum=2&amp;amp;fps=1https://www.cnblogs.com/chengxiao/p/6059914.htmlhttps://blog.csdn.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="管中窥豹：HashMap原理学习以及jdk1.8版本中源码的变更 | Ronaldo">
    <meta name="twitter:description" content="学习自https://www.cnblogs.com/skywang12345/p/3310835.htmlhttps://blog.csdn.net/unscdf117/article/details/78729674?locationNum=2&amp;amp;fps=1https://www.cnblogs.com/chengxiao/p/6059914.htmlhttps://blog.csdn.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="管中窥豹：HashMap原理学习以及jdk1.8版本中源码的变更 | Ronaldo">
    <meta property="og:description" content="学习自https://www.cnblogs.com/skywang12345/p/3310835.htmlhttps://blog.csdn.net/unscdf117/article/details/78729674?locationNum=2&amp;amp;fps=1https://www.cnblogs.com/chengxiao/p/6059914.htmlhttps://blog.csdn.">

    
    <meta name="author" content="lizhongzhen">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/logo.jpg">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Ronaldo" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2018/04/09/HashMap/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/Daniel.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Ronaldo 的主页"><img src="/images/logo.jpg" width="80" alt="Ronaldo logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Ronaldo">Ronaldo</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/3298783260/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" title="Weibo" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/lizhongzhen11" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-04-09T05:26:13.599Z" class="post-list__meta--date date">2018-04-09</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">管中窥豹：HashMap原理学习以及jdk1.8版本中源码的变更</h1>
  </header>

  <section class="post">
    <h3 id="学习自"><a href="#学习自" class="headerlink" title="学习自"></a>学习自</h3><p><a href="https://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="external">https://www.cnblogs.com/skywang12345/p/3310835.html</a><br><a href="https://blog.csdn.net/unscdf117/article/details/78729674?locationNum=2&amp;fps=1" target="_blank" rel="external">https://blog.csdn.net/unscdf117/article/details/78729674?locationNum=2&amp;fps=1</a><br><a href="https://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="external">https://www.cnblogs.com/chengxiao/p/6059914.html</a><br><a href="https://blog.csdn.net/jack__frost/article/details/69388422" target="_blank" rel="external">https://blog.csdn.net/jack__frost/article/details/69388422</a><br><a href="https://www.cnblogs.com/dennyzhangdd/p/6745282.html" target="_blank" rel="external">https://www.cnblogs.com/dennyzhangdd/p/6745282.html</a><br><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="external">https://blog.csdn.net/fan2012huan/article/details/51097331</a></p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文也是在博览网上诸位前辈们的讲解后自己对比着去理解写下的笔记,很多细节部分可以看上面的链接,下面的内容更多是自己的理解学习过程。</p>
<h3 id="jdk1-8里面的HashMap"><a href="#jdk1-8里面的HashMap" class="headerlink" title="jdk1.8里面的HashMap"></a>jdk1.8里面的HashMap</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdk1.8版本的<code>HashMap</code>源码实现与上述第一个链接中的源码略有不同,不过大同小异。比如<code>get()</code>以及<code>HashMap</code>的构造函数都有些变化。但是不妨碍我们理解其设计原理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以<code>get()</code>为例,内部就两行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写法上更简洁了些,而且这里采用了内部类<code>Node</code>。<code>Node</code>是<code>HashMap</code>的一个内部类,实现<code>Map.Entry</code>接口,本质是一个<strong>KV映射</strong>,下图中每个元素都是一个<code>Node</code>对象。<br><img src="../../../../images/hashmap.png" alt=""></p>
<p><code>HashMap</code>顾名思义是通过<strong>Hash表</strong>进行存储.<strong>为了解决哈希碰撞的问题,Java采用这种数组 + 链表方式来进行存储</strong>。下面来看看<code>Node</code>这个内部类是干嘛用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final int hash;</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Node&lt;K,V&gt; next;</div><div class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        this.hash = hash;</div><div class="line">        this.key = key;</div><div class="line">        this.value = value;</div><div class="line">        this.next = next;</div><div class="line">    &#125;</div><div class="line">    public final K getKey()        &#123; return key; &#125;</div><div class="line">    public final V getValue()      &#123; return value; &#125;</div><div class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</div><div class="line">    public final int hashCode() &#123;</div><div class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);</div><div class="line">    &#125;</div><div class="line">    public final V setValue(V newValue) &#123;</div><div class="line">        V oldValue = value;</div><div class="line">        value = newValue;</div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line">    public final boolean equals(Object o) &#123;</div><div class="line">        if (o == this)</div><div class="line">            return true;</div><div class="line">        if (o instanceof Map.Entry) &#123;</div><div class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">                Objects.equals(value, e.getValue()))</div><div class="line">                return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对比本文开头第一个链接里面的源码,其实就是1.7版本<code>HashMap</code>里面的内部类<code>Entry</code>,当然,该内部类里面的方法做了些删减。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>HashMap</code>既然是用来存储的,那么总得有增加和删除操作吧,具体对应哪个方法呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想必用过的人肯定立即能答出,<code>HashMap</code>通过<code>put</code>方法进行增加操作的,当然也有个<code>remove</code>方法进行删除。不过,这时候我却想到了之前学习<code>List</code>集合时貌似用的是<code>add()</code>啊,怎么到这里却是<code>put</code>了。老司机们肯定会说,傻了吧!<code>HashMap</code>实现的是<code>Map</code>,而<code>ArrayList</code>实现的是<code>List</code>,<code>List</code>又继承自<code>Collection</code>,而<code>Map</code>和<code>Collection</code>完全没有关系。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么,问题来了,<code>HashMap</code>里面的<code>put</code>方法是怎么实现的呢？和<code>ArrayList</code>里面的<code>add</code>有何不同？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么,看看<code>put</code>方法吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">    return putVal(hash(key), key, value, false, true);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接调了个<code>putVal()</code>然后当个甩手掌柜。那只能继续往下看了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">transient Node&lt;K,V&gt;[] table;</div><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">    if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</div><div class="line">        tab[i] = newNode(hash, key, value, null);</div><div class="line">    else &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        else if (p instanceof TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</div><div class="line">        else &#123;</div><div class="line">            for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                if ((e = p.next) == null) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, null);</div><div class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                    break;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (e != null) &#123; // existing mapping for key</div><div class="line">            V oldValue = e.value;</div><div class="line">            if (!onlyIfAbsent || oldValue == null)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    if (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>putVal()</code>一上来就在判断里把<code>table</code>赋值给<code>tab</code>然后对<code>tab</code>进行判断。那么问题又来了,<code>table</code>从哪里来的？何时赋值给它的？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在类中查找,不难发现,<code>table</code>在一开始就定义好。那么是怎么给它赋值的呢？比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HashMap map = new HashMap();</div><div class="line">map.put(&quot;one&quot;, 1);</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候,我需要去研究<code>HashMap</code>的构造函数了。<code>HashMap</code>有四个构造函数,我就不一一贴出来了。这里我调用的其实是无参构造函数,仅仅是将<code>loadFactor</code>赋值为<strong>0.75f</strong>。至于为什么是<strong>0.75f</strong>,第一个链接里面的博客讲到：<strong>默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public HashMap() &#123;</div><div class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;研究完构造函数,我发现上面例子并没有对<code>table</code>进行赋值,那么第一个判断为<code>true</code>,执行<code>tab = resize()</code>。那么<code>resize()</code>又是什么呢？看看吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</div><div class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</div><div class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</div><div class="line">final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">        Node&lt;K,V&gt;[] oldTab = table;                        // 我举的例子中,table == null,所以这里 oldTab == null</div><div class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length; // 由于oldTab == null, 所以 oldCap == 0</div><div class="line">        int oldThr = threshold;                            // 我举的例子没有对 threshold 进行初始化赋值,所以默认为0</div><div class="line">        int newCap, newThr = 0;</div><div class="line">        if (oldCap &gt; 0) &#123;</div><div class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">                threshold = Integer.MAX_VALUE;</div><div class="line">                return oldTab;</div><div class="line">            &#125;</div><div class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</div><div class="line">        &#125;</div><div class="line">        else if (oldThr &gt; 0) // initial capacity was placed in threshold</div><div class="line">            newCap = oldThr;</div><div class="line">        else &#123;               // zero initial threshold signifies using defaults</div><div class="line">            newCap = DEFAULT_INITIAL_CAPACITY;                                 // 16</div><div class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    // (int)(0.75f * 16)</div><div class="line">        &#125;</div><div class="line">        if (newThr == 0) &#123;</div><div class="line">            float ft = (float)newCap * loadFactor;                             // (float)16 * 0.75f</div><div class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div class="line">                      (int)ft : Integer.MAX_VALUE);</div><div class="line">        &#125;</div><div class="line">        threshold = newThr;     // (int)(0.75f * 16)</div><div class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; // 新建一个确定长度的数组</div><div class="line">        table = newTab;                                         // 用刚刚新建的数组对table赋值</div><div class="line">        if (oldTab != null) &#123;</div><div class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">                Node&lt;K,V&gt; e;</div><div class="line">                if ((e = oldTab[j]) != null) &#123;</div><div class="line">                    oldTab[j] = null;</div><div class="line">                    if (e.next == null)</div><div class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                    else if (e instanceof TreeNode)</div><div class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div class="line">                    else &#123; // preserve order</div><div class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">                        Node&lt;K,V&gt; next;</div><div class="line">                        do &#123;</div><div class="line">                            next = e.next;</div><div class="line">                            if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">                                if (loTail == null)</div><div class="line">                                    loHead = e;</div><div class="line">                                else</div><div class="line">                                    loTail.next = e;</div><div class="line">                                loTail = e;</div><div class="line">                            &#125;</div><div class="line">                            else &#123;</div><div class="line">                                if (hiTail == null)</div><div class="line">                                    hiHead = e;</div><div class="line">                                else</div><div class="line">                                    hiTail.next = e;</div><div class="line">                                hiTail = e;</div><div class="line">                            &#125;</div><div class="line">                        &#125; while ((e = next) != null);</div><div class="line">                        if (loTail != null) &#123;</div><div class="line">                            loTail.next = null;</div><div class="line">                            newTab[j] = loHead;</div><div class="line">                        &#125;</div><div class="line">                        if (hiTail != null) &#123;</div><div class="line">                            hiTail.next = null;</div><div class="line">                            newTab[j + oldCap] = hiHead;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return newTab;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>由于我所举的例子,先实例化一个<code>HashMap</code>对象然后<code>put</code>了一个值,所以,一开始<code>table</code>是<strong>null</strong>,<code>oldCap == 0</code>,由于也没有对<code>threshold</code>进行赋值,所以初始值也是0.</li>
<li>在我举的例子基础上,那些<code>if</code>判断都不满足条件,只能走<code>else</code>块。得到<code>newCap</code>和<code>newThr</code>的值。</li>
<li>对<code>threshold</code>进行赋值,然后新建一个长度为<strong>16</strong>的数组,并将其赋值给<code>table</code>。</li>
<li>由于我的例子初始化时,<code>oldTab == null</code>,所以第一次<code>put</code>时并不会走下面的代码。</li>
<li>当我以后进行第二次甚至更多的<code>put</code>操作时,才会继续。接下来的代码看不懂,可以直接看开头第四个链接的博客。<br><strong>看完代码仔细想想,应该明白这里的<code>resize()</code>其实是用来实现数组自增扩容的。</strong></li>
</ol>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到了这里,数组扩容完成,开始继续执行<code>putVal()</code>里面的代码。由于是第一次<code>put</code>,直接在第二个<code>if</code>判断里通过<code>tab[i] = newNode(hash, key, value, null)</code>添加新内容。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上分析的前提建立在实例化一个<code>HashMap</code>后第一次<code>put</code>,所以分析起来比较简单。如果是第二次及以上不断<code>put</code>,那么就会略微繁琐点。</p>
</blockquote>
<p><strong>此外,需要格外注意的是,</strong></p>
<ol>
<li><strong>由于<code>HashMap</code>是通过<code>p = tab[i = (n - 1) &amp; hash]</code>得到每对key-value,而其中的<code>i = (n - 1) &amp; hash</code>是通过<code>hash</code>值得到的位置下标,并不是常规数组那样从0开始依次排序的,所以<code>HashMap</code>是无序的！</strong></li>
<li><strong><code>putVal()</code>里面<code>else</code>代码块里还真的看不懂是什么意思,可以去看开头第四个链接的博客。不过可以肯定的是,<code>putVal()</code>将key-value对放进<code>HashMap</code>中,无论是直接调用<code>newNode()</code>亦或是<code>else</code>代码块里的写入覆盖,该方法均不安全。如果两个线程同时对同一处的<code>HashMap</code>进行调用,那么会引发错误,所以<code>HashMap</code>是非线程安全的。</strong></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前以我的技术实力,还无法全面清晰的理解<code>HashMap</code>的每个实现原理,以上只能管中窥豹了,文章开头给出的链接写得都非常好。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下给出几个重要的知识点：</p>
<ol>
<li>我们对某个元素进行哈希运算,得到一个存储地址,然后要进行插入的时候,发现已经被其他元素占用了,其实这就是所谓的<strong>哈希冲突</strong>,也叫哈希碰撞。</li>
<li>1.8版本的<code>HashMap</code>采用了数组 + 链表 + 红黑树的结构来解决哈希冲突。当同一个<code>hash</code>值的链表节点数不小于<strong>8</strong>时,将不再以单链表的形式存储了,会被调整成一颗<strong>红黑树</strong>。</li>
<li><code>HashMap</code>的数组长度一定是2的次幂。初始长度是<strong>16</strong>.</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1.为什么<code>HashMap</code>的初始长度是16？为什么必须是2的幂？<strong>着重看文章开头的第3个链接以及<a href="https://blog.csdn.net/super_me_jason/article/details/79726757" target="_blank" rel="external">https://blog.csdn.net/super_me_jason/article/details/79726757</a></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道对于<code>HashMap</code>的<code>table</code>而言,数据分布需要均匀(最好每项都只有一个元素,这样就可以直接找到),不能太紧也不能太松,太紧会导致查询速度慢,太松则浪费空间。计算<code>hash</code>值后,怎么才能保证<code>table</code>元素分布均与呢？我们会想到取模,但是由于取模的消耗较大,<code>HashMap</code>以前是这样处理的：调用<code>indexFor</code>方法,返回的是<code>key</code>的<code>hashcode</code>跟<strong>初始容量-1</strong>做与运算。但是1.8版本后直接在<code>resize()</code>里面通过这一段代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (e.next == null)</div><div class="line">    newTab[e.hash &amp; (newCap - 1)] = e; // newCap 是原长度</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>hashMap</code>的数组长度一定保持2的次幂,比如16的二进制表示为 <code>10000</code>,那么<code>n-1</code>就是15,二进制为<code>01111</code>,同理扩容后的数组长度为32,二进制表示为<code>100000</code>,<code>n-1</code>为31,二进制表示为<code>011111</code>。这样会保证低位全为1,而扩容后只有一位差异,也就是多出了最左位的1,这样在通过 <code>i = (n - 1) &amp; hash</code>的时候,只要<code>hash</code>对应的最左边的那一个差异位为0,就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)。数组长度保持2的次幂,<code>n-1</code>的低位都为1,会使得获得的数组索引更加均匀。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>HashMap</code>的默认长度为16,是为了降低<code>hash</code>碰撞的几率。举个例子,计算”book”的<code>hashcode</code>,假设<code>HashMap</code>的长度是10:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">hashcode</div><div class="line">十进制：3029737</div><div class="line">二进制：101110001110101110 1001</div><div class="line">length - 1：               1001</div><div class="line">index：                    1001</div><div class="line">// 再换一个hashcode试试</div><div class="line">hashcode：101110001110101110 1111</div><div class="line">length - 1：                 1001</div><div class="line">index：                      1001</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从结果可以看出,虽然<code>hashcod</code>e变化了,但是运算的结果都是<code>1001</code>,也就是说,当<strong>HashMap长度为10</strong>的时候,有些<code>index</code>结果的出现几率会更大而有些index结果永远不会出现(比如0111),这样就<strong>不符合hash均匀分布</strong>的原则。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反观<strong>长度16或者其他2的幂</strong>,<code>length - 1</code>的值是所有二进制位全为1,这种情况下,<code>index</code>的结果等同于<code>hashcode</code>后几位的值只要输入的<code>hashcode</code>本身分布均匀,<code>hash</code>算法的结果就是均匀的。</p>
<hr>
<p>2.为什么<code>HashMap</code>的动态因子是0.75f？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMap有两个参数影响其性能：初始容量和加载因子。容量是哈希表中桶的数量,初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动扩容之前可以达到多满的一种度量。当哈希表中的条目数超出了加载因子与当前容量的乘积时,则要对该哈希表进行扩容、<code>rehash</code>操作(即重建内部数据结构),扩容后的哈希表将具有两倍的原容量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常,<strong>加载因子需要在时间和空间成本上寻求一种折衷</strong>。加载因子过高,例如为1,虽然减少了空间开销,提高了空间利用率,但同时也增加了查询时间成本；加载因子过低,例如0.5,虽然可以减少查询时间成本,但是空间利用率很低,同时提高了<code>rehash</code>操作的次数。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子,以便最大限度地减少<code>rehash</code>操作次数,所以,一般在使用<code>HashMap</code>时建议根据预估值设置初始容量,减少扩容操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择<strong>0.75</strong>作为默认的加载因子,完全是时间和空间成本上寻求的一种折衷选择,至于为什么不选择0.5或0.8,笔者没有找到官方的直接说明,在<code>HashMap</code>的源码注释中也只是说是一种折中的选择。</p>
<hr>
<p>3.为什么<code>HashMap</code>的同一个<code>hash</code>值的链表节点数不小于8时调整为红黑树？为什么一定是8而不是其他的值？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于这个问题,源码中有注释讲到,翻译过来：理想情况下使用随机的哈希码,容器中节点分布在<code>hash</code>桶中的频率遵循<strong>泊松分布</strong>(具体可以查看<a href="http://en.wikipedia.org/wiki/Poisson_distribution" target="_blank" rel="external">http://en.wikipedia.org/wiki/Poisson_distribution</a>) ,按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表,可以看到链表中元素个数为<strong>8</strong>时的概率已经非常小,再多的就更少了,所以原作者在选择链表元素个数时选择了8,是根据<strong>概率统计</strong>而选择的。</p>
<hr>
<p>4.<code>HashMap</code>中保存了<code>key-value</code>,而<code>entrySet</code>也是保存了<code>key-value</code>对,这有什么意义呢？两个有何不同呢？<br>先看个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</div><div class="line">hashMap.put(&quot;one&quot;, &quot;one&quot;);</div><div class="line">hashMap.put(&quot;two&quot;, &quot;two&quot;);</div><div class="line">hashMap.put(&quot;three&quot;, &quot;three&quot;);</div><div class="line">System.out.println(hashMap);</div><div class="line">System.out.println(hashMap.entrySet());</div><div class="line">// 打印输出</div><div class="line">&#123;one=one, two=two, three=three&#125;</div><div class="line">[one=one, two=two, three=three]</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上例中可以看出两者确实不大一样。调用了<code>entrySet()</code>后打印输出的有点类似js里面的数组形式。看了下源码,发现<code>entrySet()</code>是<strong>Set</strong>类型的,而<strong>Set</strong>又继承自<strong>Collection</strong>,<code>HashMap</code>实现的是<strong>Map</strong>接口,<strong>Map</strong>与<strong>Collection</strong>本就是两种接口,并没有什么联系。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看了网上的讲解以及源码发现,1.8版本的<code>HashMap</code>调用<code>entrySet()</code>后会<strong>new</strong>一个<code>EntrySet</code>内部类的实例,而调用<code>entrySet().iterator()</code>方法会<strong>new</strong>一个内部类<code>EntryIterator</code>的实例,而该类又继承自<code>HashIterator</code>内部类且只定义了一个<code>next()</code>方法。关键点就在<code>HashIterator</code>类内部。该类内部的<code>nextNode()</code>其实就是对<code>HashMap</code>底层的数据存储结构<code>Node&lt;K,V&gt;[] table</code>进行遍历,所以采用<code>entrySet().iterator()</code>遍历的话效率更高。原因：<code>keySet</code>方式拿到的是装载<code>String</code>的<code>set</code>(需要再次转换拿到key),而<code>entrySet</code>方式拿到的是装载<code>Map.Entry</code>类型的<code>set</code>,无须再次转换,直接<code>getvalue</code>。</p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/04/10/HashTable/" title="管中窥豹：HashTable源码学习">管中窥豹：HashTable源码学习</a></h2>
                <p class="excerpt">
                
                学习自：http://www.cnblogs.com/skywang12345/p/3310887.htmlhttps://segmentfault.com/a/1190000008982905
问题1.HashTable是不是线程安全的？为什么？&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;n
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-04-10T08:51:02.790Z" class="post-list__meta--date date">2018-04-10</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/04/10/HashTable/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/04/08/java中equals/" title="java中比较String是否相同为何用equals而不是==？">java中比较String是否相同为何用equals而不是==？</a></h2>
                <p class="excerpt">
                
                参考自：https://www.cnblogs.com/baotong-9396/p/7182906.htmlhttp://www.cnblogs.com/panxuejun/p/5866869.html
如题&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;作为一个写惯了js
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-04-08T06:16:00.363Z" class="post-list__meta--date date">2018-04-08</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/04/08/java中equals/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 lizhongzhen - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
