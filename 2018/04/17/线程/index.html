<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>管中窥豹：线程基础以及Runnable、Thread源码学习 | Ronaldo</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="一、学习自https://www.zhihu.com/question/25532384https://www.zhihu.com/question/19901763http://ifeve.com/benefits/http://www.cnblogs.com/xrq730/category/733883.htmlhttp://www.cnblogs.com/skywang12345/p/jav">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="管中窥豹：线程基础以及Runnable、Thread源码学习 | Ronaldo">
    <meta name="twitter:description" content="一、学习自https://www.zhihu.com/question/25532384https://www.zhihu.com/question/19901763http://ifeve.com/benefits/http://www.cnblogs.com/xrq730/category/733883.htmlhttp://www.cnblogs.com/skywang12345/p/jav">

    <meta property="og:type" content="article">
    <meta property="og:title" content="管中窥豹：线程基础以及Runnable、Thread源码学习 | Ronaldo">
    <meta property="og:description" content="一、学习自https://www.zhihu.com/question/25532384https://www.zhihu.com/question/19901763http://ifeve.com/benefits/http://www.cnblogs.com/xrq730/category/733883.htmlhttp://www.cnblogs.com/skywang12345/p/jav">

    
    <meta name="author" content="lizhongzhen">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/logo.jpg">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Ronaldo" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2018/04/17/线程/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/Daniel.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Ronaldo 的主页"><img src="/images/logo.jpg" width="80" alt="Ronaldo logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Ronaldo">Ronaldo</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="https://github.com/lizhongzhen11/lizhongzhen11.github.io">目录</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/3298783260/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" title="Weibo" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/lizhongzhen11" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-04-17T02:29:05.167Z" class="post-list__meta--date date">2018-04-17</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">管中窥豹：线程基础以及Runnable、Thread源码学习</h1>
  </header>

  <section class="post">
    <h3 id="一、学习自"><a href="#一、学习自" class="headerlink" title="一、学习自"></a>一、学习自</h3><p><a href="https://www.zhihu.com/question/25532384" target="_blank" rel="external">https://www.zhihu.com/question/25532384</a><br><a href="https://www.zhihu.com/question/19901763" target="_blank" rel="external">https://www.zhihu.com/question/19901763</a><br><a href="http://ifeve.com/benefits/" target="_blank" rel="external">http://ifeve.com/benefits/</a><br><a href="http://www.cnblogs.com/xrq730/category/733883.html" target="_blank" rel="external">http://www.cnblogs.com/xrq730/category/733883.html</a><br><a href="http://www.cnblogs.com/skywang12345/p/java_threads_category.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/java_threads_category.html</a><br><a href="http://www.cnblogs.com/Qian123/p/5670304.html" target="_blank" rel="external">http://www.cnblogs.com/Qian123/p/5670304.html</a><br><a href="https://blog.csdn.net/ghsau/article/details/17609747" target="_blank" rel="external">https://blog.csdn.net/ghsau/article/details/17609747</a><br><a href="https://www.cnblogs.com/lcplcpjava/p/6896904.html" target="_blank" rel="external">https://www.cnblogs.com/lcplcpjava/p/6896904.html</a></p>
<h3 id="二、相关基础概念-以自问自答形式"><a href="#二、相关基础概念-以自问自答形式" class="headerlink" title="二、相关基础概念(以自问自答形式)"></a>二、相关基础概念(以自问自答形式)</h3><p><strong><a id="11">目录</a></strong></p>
<ul>
<li><a href="#1">init()</a></li>
<li><a href="#2">run和satrt源码及注释</a></li>
<li><a href="#3">run和start示例</a></li>
<li><a href="#4">getName()和Thread.currentThread().getName()</a></li>
<li><a href="#5">join()</a></li>
<li><a href="#6">wait(),notify(),notifyAll()</a><ul>
<li><a href="#61">为什么wait(),notify(),notifyAll()在 Object.class 中</a></li>
</ul>
</li>
<li><a href="#7">sleep()</a></li>
<li><a href="#8">yield()</a></li>
<li><a href="#9">interrupt()</a></li>
</ul>
<p>问题1.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初学java的人肯定经常听到<strong>多线程</strong>这个词,尤其是不懂得人听起来觉得,哇,好牛逼！<strong>多线程</strong>应该就是多个<strong>线程</strong>了,而<strong>线程</strong>是什么呢？相信很多人同时也听过<strong>进程</strong>这个词？那么<strong>进程</strong>与<strong>线程</strong>从名字上看我们就应该知道,这俩不是一个东西。但是都带了个“程”字,他俩是不是亲戚啊？</p>
<blockquote>
<p>关于<strong>进程</strong>与<strong>线程</strong>的讨论,可以看第一个链接,知乎上不少大神做出了专业的解释。给个段子理解下：<br><strong>进程是爹妈,管着众多的线程儿子</strong></p>
</blockquote>
<hr>
<p>问题2.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候,我们应该对<strong>进程</strong>和<strong>线程</strong>有了一些基础的理解。那么平常听到的<strong>多线程</strong>是多个线程一起同时进行吗？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案是否定的!<strong>一个处理器(cpu)在某一个时间点上永远都只能是一个线程！</strong>假设当前有一个cpu叫A,A中有a,b,c三个线程。多线程其实就是A在执行a线程一段时间后保存a线程执行的进度,然后去执行b或者c线程,然后又跳回来继续执行a线程,也就是说A在a,b,c三个线程中来回执行,并不是先把a线程完全执行结束才开始执行其他线程的,当然,比喻而已。</p>
<hr>
<p>问题3.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么需要多线程？</p>
<blockquote>
<p>可以看文章开头第二个链接,知乎上第一个答案很精辟。也可以看看第三个链接。<br>总结下好处：资源利用率更好,程序响应更快,程序设计在某些情况下更简单等。</p>
</blockquote>
<hr>
<p>问题4.<a href="#11">回到目录</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何写一个线程启动的示例,让它具象化？<br>示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Thread thread = <span class="keyword">new</span> Thread();</div><div class="line">		thread.start();</div><div class="line">		System.out.println(thread);                           <span class="comment">// Thread[Thread-0,5,main]</span></div><div class="line">		System.out.println(thread.getName());                 <span class="comment">// Thread-0</span></div><div class="line">		System.out.println(thread.getState());                <span class="comment">// TERMINATED</span></div><div class="line">		System.out.println(thread.currentThread());           <span class="comment">// Thread[main,5,main]</span></div><div class="line">		System.out.println(thread.currentThread().getName()); <span class="comment">// main</span></div><div class="line">		System.out.println(thread.activeCount());             <span class="comment">// 1</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//			thread.wait();</span></div><div class="line">			thread.join();</div><div class="line">			thread.sleep(<span class="number">500</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		System.out.println(thread.isAlive());                 <span class="comment">// false</span></div><div class="line"> 		thread.run();</div><div class="line">		thread.stop();</div><div class="line">		thread.yield();</div><div class="line">        thread.interrupt();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>问题5.<a href="#11">回到目录</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述示例中列出了很多常用的方法,那么这些方法分别代表着什么意思呢？为了解决这个问题,我又需要去看源码了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先,<code>Thread</code>类实现了<code>Runnable</code>接口,点开一看,<code>Runnable</code>接口里就一个<code>run()</code>方法,注释的意思是<strong>当一个实现了<code>Runnable</code>接口的对象创建了一个线程,在一个单独执行的线程中启动线程会调用<code>run</code>方法</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来回到<code>Thread</code>类中,不看不知道,一看吓一跳,<code>Thread</code>类里面竟然有9个构造函数！我直接列出我用到的也是最简单的默认构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</div><div class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>); <span class="comment">// 这里用到了 nextThreadNum(),其实就是对线程进行自增编号</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;                  <span class="comment">// 该属性用来给匿名线程自动编号的</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;     <span class="comment">// 这个方法上了同步锁</span></div><div class="line">    <span class="keyword">return</span> threadInitNumber++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><a id="1">init()</a>/<a href="#11">回到目录</a></p>
<p>默认构造函数内部调用了<code>init()</code>方法,看看这个初始化方法内部实现了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></div><div class="line">                      <span class="keyword">long</span> stackSize) &#123;</div><div class="line">    <span class="comment">// 层层调用啊,继续看</span></div><div class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></div><div class="line">                      <span class="keyword">long</span> stackSize, AccessControlContext acc) &#123;</div><div class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    Thread parent = currentThread();                        <span class="comment">// 注释说currentThread()返回一个正在执行的线程的引用</span></div><div class="line">    SecurityManager security = System.getSecurityManager(); <span class="comment">// 百度了下,大概是取得权限的意思,以后要专门分析了</span></div><div class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">/* Determine if it's an applet or not */</span></div><div class="line">        <span class="comment">/* If there is a security manager, ask the security manager what to do. */</span></div><div class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</div><div class="line">            g = security.getThreadGroup();  <span class="comment">// 归属security线程组</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/* If the security doesn't have a strong opinion of the matter use the parent thread group. */</span></div><div class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</div><div class="line">            g = parent.getThreadGroup();    <span class="comment">// 归属正在执行的线程所在的线程组</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* checkAccess regardless of whether or not threadgroup is explicitly passed in. */</span></div><div class="line">    g.checkAccess(); <span class="comment">// 这个方法我一路跟踪下去,简直了。大意是无论线程组又没有明确的通过都要检查访问</span></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Do we have the required permissions?</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</div><div class="line">            <span class="comment">// 检测是否符合 现行安全策略 的许可</span></div><div class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    g.addUnstarted();  <span class="comment">// 增加线程组里未被启动的线程数</span></div><div class="line">    <span class="keyword">this</span>.group = g;    <span class="comment">// 线程组变更</span></div><div class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();      <span class="comment">// daemon用来判断是不是守护线程的,让它与父线程(正在执行的)相统一</span></div><div class="line">    <span class="keyword">this</span>.priority = parent.getPriority(); <span class="comment">// 与父线程统一优先权</span></div><div class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</div><div class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader(); <span class="comment">// 类装载器</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</div><div class="line">    <span class="comment">// 上下文访问控制,默认构造器过来的话是null</span></div><div class="line">    <span class="keyword">this</span>.inheritedAccessControlContext = acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</div><div class="line">    <span class="keyword">this</span>.target = target;   <span class="comment">// 运行的目标对象。默认构造器过来的话是null</span></div><div class="line">    setPriority(priority);  <span class="comment">// 设置优先权</span></div><div class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</div><div class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);  <span class="comment">// 本地线程</span></div><div class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></div><div class="line">    <span class="keyword">this</span>.stackSize = stackSize; <span class="comment">// 堆栈大小。默认构造器过来是 0</span></div><div class="line">    <span class="comment">/* Set thread ID */</span></div><div class="line">    tid = nextThreadID(); <span class="comment">// 线程 id。nextThreadID()内部id自增</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><a id="2">run和satrt源码及注释</a>/<a href="#11">回到目录</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里,实例化才完成。。。是不是很复杂？没办法,我们还得继续。根据示例,接下来我调用了<code>start()</code>方法来启动线程。可是这里存在一个疑问：<strong><code>Thread</code>实现了<code>Runnable</code>接口,而<code>Runnable</code>接口明确说明启动线程必须要有<code>run</code>方法！<code>Thread</code>里的确实现了<code>run</code>方法,那么为什么不是直接调用<code>run()</code>启动线程而是调用<code>start()</code>呢？</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候,我得分别去看这两个方法的源码以及注释了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 先列出run方法的源码</div><div class="line"> * 官方注释：如果一个线程使用单独的 Runnable 运行对象构成的,那么Runnable对象的run方法会被调用。否则,这个方法不会做任何事。</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">        target.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * run 方法的注释没有明确说要通过直接调用该方法才能启动线程,注释的潜台词是线程运行时自动调用run方法？？？</div><div class="line"> * 还是先看看start方法源码以及注释再做判断吧</div><div class="line"> * start方法注释第一句就是 该方法让线程开始执行,java 虚拟机调用该线程的run方法！！！</div><div class="line"> * 调用该方法的后果是两个线程同时运行。</div><div class="line"> * 一个线程一旦被执行就不能重启。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 该方法不被主线程以及 “system” 线程组通过 VM 创建或设置来调用</div><div class="line">     * 0 对应状态 NEW</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException(); <span class="comment">// 任何一个线程在调用start前它的状态都应该是0,否则抛异常</span></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 通知线程组这个线程即将启动,这个线程可以被加进该组的线程列表并且线程组未启动的数量相应减少</div><div class="line">     * 我把add()列到下面</div><div class="line">     */</div><div class="line">    group.add(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        start0();  <span class="comment">// 这个方法很奇怪,我在下面列出来</span></div><div class="line">        started = <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (!started) &#123;</div><div class="line">                group.threadStartFailed(<span class="keyword">this</span>); <span class="comment">// 启动失败的话,将该线程从线程组中移除,并且未启动的线程数加1</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 我刚刚说 start0 这个方法很奇怪,就是因为没有方法体,不知道它是怎么实现的。</div><div class="line"> * 但是,仔细观察方法修饰符中有一个 native,特地上网百度了下才知道：</div><div class="line"> * native关键字说明其修饰的方法是一个原生态方法,方法对应的实现不是在当前文件,而是在用其他语言(如C和C++)实现的文件中。</div><div class="line"> * Java语言本身不能对操作系统底层进行访问和操作,但是可以通过JNI接口调用其他语言来实现对底层的访问。</div><div class="line"> * JNI是Java本机接口(Java Native Interface),是一个本机编程接口,它是Java软件开发工具箱(java Software Development Kit, SDK)的一部分。</div><div class="line"> * JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API(JNI的一部分)可以用来将Java虚拟机(JVM)嵌入到本机应用程序中,</div><div class="line"> * 从而允许程序员从本机代码内部调用Java代码。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">// ThreadGroup.class</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (destroyed) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (threads == <span class="keyword">null</span>) &#123;</div><div class="line">            threads = <span class="keyword">new</span> Thread[<span class="number">4</span>];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthreads == threads.length) &#123;</div><div class="line">            threads = Arrays.copyOf(threads, nthreads * <span class="number">2</span>); <span class="comment">// 这里其实对线程组扩大长度为原来的2倍</span></div><div class="line">        &#125;</div><div class="line">        threads[nthreads] = t; <span class="comment">// 把线程加进去</span></div><div class="line">            nthreads++;  <span class="comment">// 线程数加1</span></div><div class="line">            nUnstartedThreads--; <span class="comment">// 未启动的线程数减少</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可算是把<code>start</code>和<code>run</code>两个方法的实现和注释看完了,现在对于线程为什么需要用<code>start()</code>来启动应该了解了吧。这个时候,不妨看看文章开头的链接以及网上前辈们的讲解做对比,看有没有遗漏或者是否真的懂。幸亏留个心眼对比了下,还真的发现有点出入,还是自己理解的不足。</p>
<blockquote>
<p><code>start()</code>会启动一个新线程,并在新线程中运行<code>run()</code>方法。这个我们都知道,但是：<br><strong>直接调用<code>run()</code>,则会直接在当前线程中运行<code>run()</code>方法,并不会启动一个新线程来运行<code>run()</code>。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看来,我的英语翻译水平不够好,<code>run()</code>的注释翻译时就没有理解一个独立的<code>Runnable</code>对象是什么意思,下意识的认为必须是一个新线程,其实不是的,在当前线程调用<code>run()</code>也是可以的,只是不会启动新线程。</p>
</blockquote>
<hr>
<p><a id="3">run和start示例</a>/<a href="#11">回到目录</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对<code>run()</code>直接调用还是通过<code>start()</code>调用写个小例子进行对比：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunStart</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		TestRunStart testRunStart = <span class="keyword">new</span> TestRunStart();</div><div class="line">		testRunStart.run();</div><div class="line">		testRunStart.start();</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" is running!"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 打印输出</span></div><div class="line">main is running!</div><div class="line">Thread-<span class="number">0</span> is running!</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这个例子很明显的反映出<code>start()</code>与<code>run()</code>的区别了。直接调用<code>run()</code>其实就是调用<code>main</code>这个主线程的<code>run()</code>方法而已！</p>
</blockquote>
<hr>
<p><a id="4">getName()和Thread.currentThread().getName()</a>/<a href="#11">回到目录</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;紧接着,又有一个比较奇怪的点了。<code>Thread</code>类里定义了<code>getName()</code>方法,而我看到网上案例打印线程名都是用的<code>Thread.currentThread().getName()</code>,这两者有区别吗？</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实在实例化时,<code>init()</code>方法已经对<code>name</code>进行了赋值,而<code>getName()</code>方法就是返回<code>name</code>值,而这个<code>name</code>指的就是实例化的尚未启动的线程名。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而<code>Thread.currentThread().getName()</code>从名字上来看也知道,这里得到的其实是<strong>当前正在执行这段代码的线程名！！！</strong></p>
</blockquote>
<p>另外,<code>currentThread()</code>也是<code>native</code>修饰的,看不到它的实现代码。</p>
<p><code>activeCount()</code>用来返回当前活跃线程的大致数量的,这里就不赘述了。</p>
<hr>
<p><a id="5">join()</a>/<a href="#11">回到目录</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;紧跟示例步骤,我们到达了<code>join()</code>方法,这方法干嘛的呢？看看源码和注释吧！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    join(<span class="number">0</span>); <span class="comment">// 继续调用</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 这个方法核心部分是调用了wait()方法,没大看懂什么意思,就为了等待？</div><div class="line"> * 看看wait()方法吧</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</div><div class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (isAlive()) &#123;</div><div class="line">            wait(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">while</span> (isAlive()) &#123;</div><div class="line">            <span class="keyword">long</span> delay = millis - now;</div><div class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            wait(delay);</div><div class="line">            now = System.currentTimeMillis() - base;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Object.class</span></div><div class="line"><span class="comment">// 操蛋啊,看不了。。。百度吧</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</div></pre></td></tr></table></figure></p>
<p><strong>关于<code>join()</code>这篇博客讲的不错：<a href="https://www.cnblogs.com/lcplcpjava/p/6896904.html" target="_blank" rel="external">https://www.cnblogs.com/lcplcpjava/p/6896904.html</a></strong>。总结下：</p>
<blockquote>
<ol>
<li><code>join</code>方法的主要作用就是同步,它可以使得线程之间的<strong>并行执行变为串行执行</strong>。比如a,b两个线程都要<code>start</code>时,在<code>a.start()</code>之后调用<code>a.join()</code>,然后才调用<code>b.start()</code>,b线程会等a线程执行一段时间才会开始执行,具体等待时间看传入的值。</li>
<li><code>join</code>方法必须在线程调用<code>start</code>方法后调用才有效。</li>
<li><code>join(0)</code>并不是等待0秒,而是无线等待至上一个线程执行结束后才开始执行下一个线程。</li>
</ol>
</blockquote>
<hr>
<p><a id="6">wait(),notify(),notifyAll()</a>/<a href="#11">回到目录</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然看不了<code>wait()</code>方法的源码实现,但是还是有必要了解一下它干什么用的？</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>wait()</code>的作用是让当前线程进入等待状态,同时,<code>wait()</code>也会让当前线程释放它所持有的锁。而<code>notify()</code>和<code>notifyAll()</code>的作用,则是唤醒当前对象上的等待线程；<code>notify()</code>是唤醒单个线程,而<code>notifyAll()</code>是唤醒所有的线程。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在调用<code>wait()</code>之前,线程必须获得该对象的锁,因此只能在同步方法/同步代码块中调用<code>wait()</code>方法。</strong></p>
</blockquote>
<ul>
<li><code>wait(0)</code>：没有指定时间,会一直等待下去直到被唤醒或者打断</li>
<li><code>wait(1000)</code>：1S后自动超时唤醒</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面还提到了<code>notify()</code>和<code>notifyAll()</code>两个方法,这两方法配合<code>wait()</code>使用,那么顺便把这两个方法也研究下。</p>
<ul>
<li><code>notify()</code>：唤醒在此对象监视器上等待的单个线程。<strong>如果同时有多个线程在等待,那么该方法会唤醒其中一个线程。</strong></li>
<li><code>notifyAll()</code>：唤醒在此对象监视器上等待的所有线程。</li>
<li>和<code>wait()</code>一样,<code>notify()</code>和<code>notifyAll()</code>也要在同步方法/同步代码块中调用。</li>
</ul>
<p>下面列出<code>notify()</code>的注释翻译,蛮长的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 唤醒正在该对象监视器上等待的单个线程。如果该对象上有多个线程在等待,其中一个会被唤醒。</div><div class="line"> * 对于多个线程等待唤醒的情况下,会任意选择一个唤醒。</div><div class="line"> * 调用任何一种 wait 方法都能使对象监视器上的一个线程进入等待状态。</div><div class="line"> * 被唤醒的线程不能继续运行直到当前线程交出对象上的锁。</div><div class="line"> * 被唤醒的线程将会和该对象上其它活跃的线程竞争对象锁。</div><div class="line"> * 举个例子,唤醒线程在下一个线程锁住该对象时没有可靠的优劣势。</div><div class="line"> * 该方法只能被拥有当前对象监视器的线程调用。</div><div class="line"> * 线程成为对象监视器的主人只有三种方法：</div><div class="line"> * 1.通过执行该对象 synchronized 实例方法</div><div class="line"> * 2.通过执行该对象 synchronized 代码块</div><div class="line"> * 3.对象是类的话,通过执行类的 synchronized 静态方法</div><div class="line"> *</div><div class="line"> * 一段时间内只有一个线程能拥有对象的监视器。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看完源码后肯定在想,怎么用？他三怎么配合？来个案例吧,直观点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWaitNotify</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ThreadA threadA = <span class="keyword">new</span> ThreadA(<span class="string">"threadA"</span>);</div><div class="line">		ThreadB threadB = <span class="keyword">new</span> ThreadB(<span class="string">"threadB"</span>);</div><div class="line">		threadA.start();</div><div class="line">		<span class="keyword">synchronized</span> (threadA) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">				threadA.wait(<span class="number">3000</span>);</div><div class="line">				<span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">" wait "</span> + (end - start));</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		threadB.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" is running..."</span>);</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">				wait(<span class="number">5000</span>);</div><div class="line">				<span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">" wait "</span> + (end - start));</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" is running..."</span>);</div><div class="line">			<span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">			notify();</div><div class="line">			<span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" notify "</span> + (end - start));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 某次打印输出</span></div><div class="line">threadA is running... <span class="comment">// 3s后才开始打印输出第二行及以下内容</span></div><div class="line">main wait <span class="number">3001</span></div><div class="line">threadB is running...</div><div class="line">threadB notify <span class="number">0</span>      <span class="comment">// 2s后才开始打印输出最后一行内容</span></div><div class="line">threadA wait <span class="number">5000</span></div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于这个示例的打印输出我不是很理解。仔细看我的代码,我分别在<code>ThreadA</code>和<code>ThreadB</code>两个类内的<code>run</code>方法中调用了<code>wait()</code>和<code>notify()</code>方法,令我不解的是,为什么当<code>threadA.start()</code>后,主线程等待了3s,<strong><code>threadB</code>线程居然在执行！！！</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>不是说<code>wait()</code>方法会暂停线程运行且其他线程要等暂停的线程执行完成后才能执行吗？(<code>join()</code>方法就是这样的效果)</strong>。<code>ThreadA</code>里的<code>run()</code>方法明明还调用了<code>wait(5000)</code>啊,不应该等5s过后,<code>threadB</code>线程才能开始执行啊？为什么<code>threadA</code>暂停运行时主线程以及<code>threadB</code>线程依然能运行呢？？？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里,我似乎走误了一个误区！<strong>去上面仔细看看<code>join()</code>的示例,明明是两个线程都在<code>main()</code>里面调用,中间夹杂着<code>join()</code>,这不就跟我这里的示例中在<code>main()</code>里面<code>threadB.start()</code>之前调用了<code>wait(3000)</code>一样的结果吗！！！的确是等待了3s后才开始执行下面的啊！</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>但是！我不理解为什么不是等待5s去执行<code>threadB.start()</code>而是等待了3s就执行！我明明有在<code>ThreadA.class</code>里的<code>run()</code>方法中调用了<code>wait(5000)</code>,怎么没有等我<code>threadA</code>执行完再去执行<code>threadB</code>？难道<code>threadA</code>没有霸占住 cpu 吗？<code>notify()</code>起作用了吗？</strong>把上面的例子改一下对照着看:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (threadA) &#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">		threadA.wait(<span class="number">3000</span>);</div><div class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" wait "</span> + (end - start));</div><div class="line">		threadA.notify();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 某一次打印输出</span></div><div class="line">threadA is running...</div><div class="line">main wait <span class="number">3000</span></div><div class="line">threadA wait <span class="number">3000</span></div><div class="line">threadB is running...</div><div class="line">threadB notify <span class="number">0</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对比上一个例子发现有明显变化,<code>ThreadA.class</code>中的<code>wait(5000)</code>并没有起作用,这是因为在<code>main()</code>方法里调用了<code>threadA.notify()</code>强行唤醒了<code>threadA</code>线程。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而对于上一个例子中主线程等待3S后,没有等待<code>threadA</code>线程执行完后,而是直接执行<code>threadB</code>线程的问题。很可能因为在<code>ThreadA.class</code>中调用的<code>wait(5000)</code>只是让<code>threadA</code>线程等待而不影响主线程。但是在<code>main()</code>里面调用<code>wait(3000)</code>实际上同时让主线程也等待了3S,此时主线程相当于进入“阻塞”状态。3S后主线程继续运行。<br>可以参考：<a href="http://www.cnblogs.com/skywang12345/p/3479224.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3479224.html</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个问题,在<code>ThreadB.class</code>中调用的<code>notify()</code>貌似没有对<code>threadA</code>线程起作用,并没有唤醒它,这是为什么呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>很简单,<code>ThreadB.class</code>中<code>run()</code>方法内<code>synchronized</code>代码块其实绑定的是<code>threadB</code>线程,根本就跟<code>threadA</code>无关呀,它获取不到<code>threadA</code>的同步锁,就没法唤醒<code>threadA</code>线程啊~</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题又来了,如何通过<code>threadB.notify()</code>去唤醒<code>threadA</code>线程？看下面我粗糙的改写代码吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	ThreadA threadA = <span class="keyword">new</span> ThreadA(<span class="string">"threadA"</span>);</div><div class="line">	ThreadB threadB = <span class="keyword">new</span> ThreadB(threadA);</div><div class="line">	threadA.start();</div><div class="line">	<span class="keyword">synchronized</span> (threadA) &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">			threadA.wait(<span class="number">3000</span>);</div><div class="line">			<span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" wait "</span> + (end - start));</div><div class="line">			threadB.start();</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">		</div><div class="line">&#125;</div><div class="line"><span class="comment">// ThreadB.class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	ThreadA threadA;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(ThreadA threadA)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(threadA);</div><div class="line">		<span class="keyword">this</span>.threadA = threadA;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (threadA) &#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" is running..."</span>);</div><div class="line">			<span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">			threadA.notify();</div><div class="line">			<span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" notify "</span> + (end - start));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 某一次打印</span></div><div class="line">threadA is running...</div><div class="line">main wait <span class="number">3000</span></div><div class="line">Thread-<span class="number">0</span> is running...</div><div class="line">Thread-<span class="number">0</span> notify <span class="number">0</span></div><div class="line">threadA wait <span class="number">3001</span></div></pre></td></tr></table></figure></p>
<hr>
<p><a id="61">为什么wait(),notify(),notifyAll()在 Object.class 中</a>/<a href="#11">回到目录</a></p>
<blockquote>
<p><strong>注意：<code>wait(),notify(),notifyAll()</code>是Object.class里面的方法！！！</strong></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题来了,为什么把该方法定义在 Object.class内而不是Thread.class内呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参考：<a href="http://www.cnblogs.com/skywang12345/p/3479224.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3479224.html</a></p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重点结论：<strong><code>notify()</code>, <code>wait()</code>依赖于“同步锁”,而“同步锁”是对象锁持有,并且每个对象有且仅有一个！这就是为什么<code>notify()</code>, <code>wait()</code>等函数定义在<code>Object</code>类,而不是<code>Thread</code>类中的原因。</strong></p>
</blockquote>
<hr>
<p><a id="7">sleep()</a>/<a href="#11">回到目录</a><br>可以看：<a href="http://www.cnblogs.com/skywang12345/p/3479256.html" target="_blank" rel="external">http://www.cnblogs.com/skywang12345/p/3479256.html</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 让当前执行的线程休眠,暂时停止运行指定的毫秒数。</div><div class="line"> * 受系统定时器和调度器精度的影响。</div><div class="line"> * 线程不会丢失任何监视器的所有权。和wait()不同,wait()会让出所有权</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</div></pre></td></tr></table></figure>
<p>一个小例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSleep</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ThreadC threadC = <span class="keyword">new</span> ThreadC(<span class="string">"threadC"</span>);</div><div class="line">		threadC.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadC</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">				System.out.printf(<span class="string">"%s: %d\n"</span>, <span class="keyword">this</span>.getName(), i);</div><div class="line">				<span class="comment">// i 能被4整除时,休眠2000毫秒</span></div><div class="line">				<span class="keyword">if</span>(i % <span class="number">4</span> == <span class="number">0</span>) &#123;</div><div class="line">					Thread.sleep(<span class="number">2000</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException  e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><a id="8">yield()</a>/<a href="#11">回到目录</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 提示调度器当前线程能够做出让步,但是调度器可以忽略这个提示。</div><div class="line"> * 让步是一种尝试,以改善线程之间的相对进展,否则将过度利用CPU。</div><div class="line"> * 不怎么用,很少合适</div><div class="line"> * 在设计并发控制结构时,也可能是有用的,例如在 java.util.concurrent.locks 包</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>一个使用例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ThreadD threadD = <span class="keyword">new</span> ThreadD(<span class="string">"threadD"</span>);</div><div class="line">		ThreadD threadD2 = <span class="keyword">new</span> ThreadD(<span class="string">"threadD2"</span>);</div><div class="line">		threadD.start();</div><div class="line">		threadD2.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadD</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ThreadD</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">			System.out.printf(<span class="string">"%s [%d]:%d\n"</span>, <span class="keyword">this</span>.getName(), <span class="keyword">this</span>.getPriority(), i);</div><div class="line">			<span class="comment">// i整除2时，调用yield</span></div><div class="line">			<span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">				Thread.yield();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 某次打印</span></div><div class="line">threadD2 [<span class="number">5</span>]:<span class="number">0</span></div><div class="line">threadD [<span class="number">5</span>]:<span class="number">0</span></div><div class="line">threadD2 [<span class="number">5</span>]:<span class="number">1</span></div><div class="line">threadD2 [<span class="number">5</span>]:<span class="number">2</span></div><div class="line">threadD [<span class="number">5</span>]:<span class="number">1</span></div><div class="line">threadD [<span class="number">5</span>]:<span class="number">2</span></div><div class="line">threadD2 [<span class="number">5</span>]:<span class="number">3</span></div><div class="line">threadD2 [<span class="number">5</span>]:<span class="number">4</span></div><div class="line">threadD [<span class="number">5</span>]:<span class="number">3</span></div><div class="line">threadD [<span class="number">5</span>]:<span class="number">4</span></div></pre></td></tr></table></figure></p>
<p><strong><code>yield()</code>与<code>wait()</code>区别：</strong></p>
<ol>
<li><code>wait()</code>是让线程由“运行状态”进入到“等待(阻塞)状态”,而<code>yield()</code>是让线程由“运行状态”进入到“就绪状态”。</li>
<li><code>wait()</code>是会线程释放它所持有对象的同步锁,而<code>yield()</code>方法不会释放锁。</li>
</ol>
<hr>
<p><a id="8">interrupt()</a>/<a href="#11">回到目录</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法是<code>Thread.class</code>里面的,源码也只露出了一丢丢,但是看网上的讲解,基本上内容还是蛮多的。继续套路,贴代码和注释翻译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object blockerLock = <span class="keyword">new</span> Object();</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 中断线程,简单粗暴</div><div class="line"> * 除非中断自己,否则总是允许的。</div><div class="line"> * 如果线程调用了 wait,join,sleep方法进入阻塞状态,然后调用该方法会报 InterruptedException</div><div class="line"> * 如果线程在 java.nio.channels.InterruptibleChannel 上操作 I/O 被阻塞,通道会被关闭,</div><div class="line"> * 设置线程的中断状态并且线程会收到 java.nio.channels.ClosedByInterruptException</div><div class="line"> * 如果线程在 java.nio.channels.Selector 上被阻塞,设置中断状态并且立即从选择操作中 可能 返回一个 非0 值,</div><div class="line"> * 仅仅作为 java.nio.channels.Selector#wakeup 方法被调用的返回值。</div><div class="line"> * 如果没有上述条件,那么会立即设置中断状态。</div><div class="line"> * 中断死亡的线程没有任何效果。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</div><div class="line">        checkAccess();              <span class="comment">// 检查权限</span></div><div class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</div><div class="line">        Interruptible b = blocker;</div><div class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</div><div class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></div><div class="line">            b.interrupt(<span class="keyword">this</span>);      <span class="comment">// 在 Interruptible包里,看不到源码</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    interrupt0(); <span class="comment">// native 修饰的,看不到源码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总算将示例中用到的方法都过了一遍,相信大家对<code>Thread.class</code>也有了比较清晰的理解了,但是,这里还是很基础的,后续还会对多线程相关知识继续学习,多线程知识点和用处还是很广的,加油！！！</p>

  </section>

</article>

<section class="read-more">
           
    
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/04/16/Queue/" title="管中窥豹：java队列(Queue)学习一--ArrayDeque">管中窥豹：java队列(Queue)学习一--ArrayDeque</a></h2>
                <p class="excerpt">
                
                一、学习自https://www.cnblogs.com/CarpenterLee/p/5468803.htmlhttps://blog.csdn.net/u011240877/article/details/52860924https://www.cnblogs.com/Dylansuns/arc
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-04-16T02:55:09.290Z" class="post-list__meta--date date">2018-04-16</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/04/16/Queue/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 lizhongzhen - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
