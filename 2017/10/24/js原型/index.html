<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>js原型对象 | Ronaldo</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="摘抄自 https://segmentfault.com/a/1190000010842024拓展理解：https://github.com/mqyqingfeng/Blog/issues/2概念理解什么是原型对象呢？有以下几点1.构造函数有一个 prototype 属性，指向构造函数的原型对象。而实例有一个 __proto__ 属性，也指向原型对象。

根据 MDN https://develo">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="js原型对象 | Ronaldo">
    <meta name="twitter:description" content="摘抄自 https://segmentfault.com/a/1190000010842024拓展理解：https://github.com/mqyqingfeng/Blog/issues/2概念理解什么是原型对象呢？有以下几点1.构造函数有一个 prototype 属性，指向构造函数的原型对象。而实例有一个 __proto__ 属性，也指向原型对象。

根据 MDN https://develo">

    <meta property="og:type" content="article">
    <meta property="og:title" content="js原型对象 | Ronaldo">
    <meta property="og:description" content="摘抄自 https://segmentfault.com/a/1190000010842024拓展理解：https://github.com/mqyqingfeng/Blog/issues/2概念理解什么是原型对象呢？有以下几点1.构造函数有一个 prototype 属性，指向构造函数的原型对象。而实例有一个 __proto__ 属性，也指向原型对象。

根据 MDN https://develo">

    
    <meta name="author" content="lizhongzhen">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/logo.jpg">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Ronaldo" href="/atom.xml">
    

    <link rel="canonical" href="http://yoursite.com/2017/10/24/js原型/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/Daniel.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Ronaldo 的主页"><img src="/images/logo.jpg" width="80" alt="Ronaldo logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Ronaldo">Ronaldo</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="https://github.com/lizhongzhen11/lizhongzhen11.github.io">目录</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/3298783260/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo" title="Weibo" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/lizhongzhen11" title="GitHub" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-10-24T07:37:13.530Z" class="post-list__meta--date date">2017-10-24</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">js原型对象</h1>
  </header>

  <section class="post">
    <h3 id="摘抄自-https-segmentfault-com-a-1190000010842024"><a href="#摘抄自-https-segmentfault-com-a-1190000010842024" class="headerlink" title="摘抄自 https://segmentfault.com/a/1190000010842024"></a>摘抄自 <a href="https://segmentfault.com/a/1190000010842024" target="_blank" rel="external">https://segmentfault.com/a/1190000010842024</a></h3><h3 id="拓展理解：https-github-com-mqyqingfeng-Blog-issues-2"><a href="#拓展理解：https-github-com-mqyqingfeng-Blog-issues-2" class="headerlink" title="拓展理解：https://github.com/mqyqingfeng/Blog/issues/2"></a>拓展理解：<a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="external">https://github.com/mqyqingfeng/Blog/issues/2</a></h3><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p><strong>什么是原型对象呢？有以下几点</strong><br>1.构造函数有一个 prototype 属性，指向构造函数的原型对象。而实例有一个 <code>__proto__</code> 属性，也指向原型对象。</p>
<blockquote>
<p>根据 MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype</a> 解释 Object.prototype 属性表示 Object 的原型对象。<br>······<br>PS：准确的说，实例指向原型对象的是 <code>[[Prototype]]</code> 属性，但这是一个隐式属性，脚本不可访问。因此浏览器厂商提供了一个属性 <code>__proto__</code> ，用来显式指向原型对象，但它并不是ECMA规范。</p>
</blockquote>
<p><strong>注意函数的是 <code>prototype</code> 属性，实例的是 <code>__proto__</code> 属性，不要弄错</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Person (name) &#123;</div><div class="line">    this.name = name</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里有一个构造函数 <em>Person</em>，这时，我们创建一个 Person 的实例 person<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var person = new Person(&quot;张三&quot;)</div></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>按照上边的理论，就可以表示为：Person.prototype === person.<code>__proto__</code>，他们指向的都是原型对象</strong></p>
<hr>
<p>2.通过同一个构造函数实例化的多个实例对象具有同一个原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var person1 = new Person(&quot;张三&quot;);</div><div class="line">var person2 = new Person(&quot;李四&quot;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p><code>person1.__proto__</code>、<code>person2.__proto__</code>、<code>Person.prototype</code>他们是两两相等的。</p>
</blockquote>
<hr>
<p>3.原型对象有一个<code>constructor</code>属性，指向该原型对象对应的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person.prototype.constructor === Person</div><div class="line">person.__proto__.constructor === Person</div></pre></td></tr></table></figure></p>
<hr>
<p>4.实例对象本身并没有<code>constructor</code>属性，但它可以继承原型对象的<code>constructor</code>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">person1.constructor === Person</div><div class="line">person2.constructor === Person</div></pre></td></tr></table></figure></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>还是以构造函数<code>Person</code>为例，稍微改一下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">    this.sayName = function()&#123;</div><div class="line">        console.log(this.name)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var person1 = new Person(&quot;张三&quot;)</div><div class="line">var person2 = new Person(&quot;李四&quot;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>我们在构造函数Person中增加了一个方法sayName，这样Person的实例person1、person2就各自都有了一个sayName方法。<br>注意，我说的是各自，什么意思呢？就是说每次创建一个实例，就要在内存中创建一个sayName方法，这些sayName并不是同一个sayName。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person1.sayName === person2.sayName // false</div></pre></td></tr></table></figure>
<blockquote>
<p>多个实例重复创建相同的方法，这显然是浪费资源的。这个时候，我们的原型对象登场了。假如构造函数中的方法我们这样写：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person (name) &#123;</div><div class="line">    this.name = name</div><div class="line">&#125;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">    console.log(this.name)</div><div class="line">&#125;</div><div class="line">var person1 = new Person(&quot;张三&quot;)</div><div class="line">var person2 = new Person(&quot;李四&quot;)</div></pre></td></tr></table></figure>
<blockquote>
<p>和之前的区别是，我们将sayName方法写到了构造函数的原型对象上，而不是写在构造函数里。</p>
</blockquote>
<p><strong>这里要先提一个概念，就是当对象找属性或者方法时，先在自己身上找，找到就调用。在自己身上找不到时，就会去他的原型对象上找。这就是原型链的概念，先点到这，大家知道这件事就可以了。</strong></p>
<blockquote>
<p>这里就要回顾之前的知识了：<em>通过同一个构造函数实例化的多个实例对象具有同一个原型对象</em></p>
<hr>
<p><code>person1</code>和<code>person2</code>上显然是没有<code>sayName</code>方法的，但是他们的原型对象有啊。</p>
<hr>
<p>所以这里的 person1.sayName 和 person2.sayName，实际上都是继承自他原型对象上的 sayName 方法，既然原型对象是同一个，那sayName方法自然也是同一个了，所以此时：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person1.sayName === person2.sayName // true</div></pre></td></tr></table></figure>
<blockquote>
<p>将需要共享的方法和属性放到原型对象上，实例在调用这些属性和方法时，不用每次都创建，从而节约资源，这就是原型对象的作用。</p>
</blockquote>
<h3 id="共享带来的“烦恼”"><a href="#共享带来的“烦恼”" class="headerlink" title="共享带来的“烦恼”"></a>共享带来的“烦恼”</h3><p><strong>但是，既然是共享，就有一点问题了，还是<code>Person</code>构造函数，我们再改造下</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">    this.name = name</div><div class="line">&#125;</div><div class="line">Person.prototype.ageList = [12,16,18]</div><div class="line">var person1 = new Person(&quot;张三&quot;)</div><div class="line">var person2 = new Person(&quot;李四&quot;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这时，我们在<code>person1</code>上做一些操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person1.ageList.push(30)</div></pre></td></tr></table></figure>
<blockquote>
<p>看一下此时<code>person2.ageList</code>是什么</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person2.ageList // [12,16,18,30]</div></pre></td></tr></table></figure>
<blockquote>
<p>有点意思，<code>person2</code>上的<code>ageList</code>也多了30</p>
</blockquote>
<p><strong>原因其实还是因为共享</strong></p>
<blockquote>
<p>共享不好的地方就是：一个实例对引用类型（数组、对象、函数）的属性进行修改，会导致原型对象上的属性修改（其实修改的就是原型对象上的属性，实例是没有这个属性的），进而导致所有的实例中，这个属性都改了！</p>
<hr>
<p>很显然，大部分时候，我们喜欢共享，可以节约资源。但是不喜欢每一个实例都受影响，要不还创建不同的实例干嘛，用一个不就好了（摊手）。</p>
<hr>
<p>所以，我们需要把那些需要共享的属性和方法，写在原型对象上，而每个实例单独用的、不希望互相影响的属性，就写在构造函数里边。类似这样：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name</div><div class="line">    this.ageList = [12, 16, 18]</div><div class="line">&#125;</div><div class="line">var person1 = new Person(&quot;张三&quot;)</div><div class="line">var person2 = new Person(&quot;李四&quot;)</div><div class="line">person1.ageList.push(30)</div><div class="line">person1.ageList // [12, 16, 18, 30]</div><div class="line">person2.ageList // [12, 16, 18]</div></pre></td></tr></table></figure>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p><strong>关于原型对象，还有两个坑，需要和大家说一下。</strong><br>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name)&#123;</div><div class="line">    this.name = name</div><div class="line">&#125;</div><div class="line">Person.prototype.ageList = [12, 16, 18]</div><div class="line">var person1 = new Person(&quot;张三&quot;)</div><div class="line">var person2 = new Person(&quot;李四&quot;)</div><div class="line">person1.ageList.push(30)</div><div class="line">person2.ageList // [12, 16, 18, 30]</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里没问题，但是假如把<code>person1.ageList.push(30)</code>改为<code>person1.ageList = [1, 2, 3]</code>，结果会是什么呢？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person2.ageList // [12, 16, 18]</div></pre></td></tr></table></figure>
<blockquote>
<p>这里就奇怪了，明明都是对<code>person1.ageList</code>进行操作，怎么就不一样呢？</p>
<hr>
<p>其实原因在于，<code>person1.ageList = [1, 2, 3]</code>是一个赋值操作。</p>
<hr>
<p>我们说过，<em>person1本身是没有<code>ageList</code>属性的，而赋值操作，会给person1增加自己的<code>ageList</code>属性</em>。既然自己有了，也就不用去原型对象上找了。这个时候，原型对象的ageList其实是没有变化的。而person2没有自己的ageList属性，所以person2.ageList还是继承自原型，就是[12, 16, 18]。</p>
</blockquote>
<p>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">    this.name = name</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">    ageList: [12, 16, 18]</div><div class="line">&#125;</div><div class="line">var person1 = new Person(&quot;张三&quot;)</div><div class="line">var person2 = new Person(&quot;李四&quot;)</div><div class="line">person1.ageList.push(30)</div><div class="line">person2.ageList // [12, 16, 18, 30]</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里依然没毛病，但是写法上有一个变化：我们不再采用Person.prototype.ageList = [12, 16, 18]的形式赋值，而是给Person.prototype赋值了一个对象，对象中有ageList。</p>
<hr>
<p>这样看貌似没有问题，用起来也都一样：改变person1.ageList，person2.ageList也变化了，说明person1.ageList和person2.ageList还是继承自同一个原型对象。</p>
</blockquote>
<p><strong>但是，这里有一个问题，之前我们说过：</strong></p>
<blockquote>
<p>实例对象本身并没有constructor属性，但它可以继承原型对象的constructor属性</p>
</blockquote>
<p><strong>但是这里</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">person1.constructor === Person // false</div><div class="line">person2.constructor === Person // false</div></pre></td></tr></table></figure></p>
<p><strong>为什么呢？</strong></p>
<blockquote>
<p>因为通过给Person.prototype赋值一个对象，就修改了原型对象的指向，此时原型对象的constructor指向内置构造函数Object了(此时打印Person.prototype.constructor得到Object)，使用Person.prototype.ageList = [12, 16, 18]的形式赋值，就不会造成这样的问题。</p>
<hr>
<p>所以当给原型对象赋值一个新对象时，切记将原型对象的constructor指回原构造函数:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person.prototype.constructor = Person</div></pre></td></tr></table></figure>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/10/25/js字典/" title="js字典操作">js字典操作</a></h2>
                <p class="excerpt">
                
                今天小伙伴问了我你知道js字典操作吗？我是一脸懵逼的，那是什么？遂上网搜，看到答案只想说原来如此。。。所以还是记下来吧
首先，js的数组 Array 既是一个数组，也是一个字典。

数组用法

123456var test = new Array()test[0] = &quot;a&quot;test[1] = &quot;b
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-10-25T01:31:49.063Z" class="post-list__meta--date date">2017-10-25</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2017/10/25/js字典/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/10/24/js遍历方法/" title="js map、forEach、filter、reduce、some、every">js map、forEach、filter、reduce、some、every</a></h2>
                <p class="excerpt">
                
                请参考 MDN1.map方法
概述：map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。
语法：123let array = arr.map(function callback(currentValue, index, array) &amp;#123;     //
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-10-24T03:36:53.957Z" class="post-list__meta--date date">2017-10-24</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2017/10/24/js遍历方法/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 lizhongzhen - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
